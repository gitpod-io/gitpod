# Gitpod Project Intelligence

This file captures important patterns, preferences, and project intelligence that help me work more effectively with the Gitpod codebase. It serves as a learning journal that will be updated as I discover new insights.

## Project Structure Patterns

- **Component Organization**: The project is organized into components, each with its own directory in the `components/` folder
- **API Definitions**: API definitions are typically in separate packages with `-api` suffix (e.g., `content-service-api`)
- **Protocol Buffers**: gRPC service definitions use Protocol Buffers (`.proto` files)
- **Build Configuration**: Each component has a `BUILD.yaml` file defining its build configuration
- **Docker Configuration**: Components that run as containers have a `leeway.Dockerfile`

## Code Style Preferences

- **Go Code**:
  - Follow standard Go conventions (gofmt)
  - Error handling with explicit checks
  - Context propagation for cancellation
  - Structured logging

- **TypeScript Code**:
  - Use TypeScript for type safety
  - React for UI components
  - Functional components with hooks
  - ESLint and Prettier for formatting

## Development Workflow

- **Build System**: Use Leeway for building components
  - `leeway build` to build specific components
  - `leeway exec` to run commands across components

- **Testing**:
  - Unit tests alongside code
  - Integration tests in separate directories
  - End-to-end tests in the `test/` directory

- **Local Development**:
  - Use Gitpod workspaces for development (dogfooding)
  - Components can be run individually for testing
  - Preview environments for testing changes

## Critical Implementation Paths

- **Workspace Lifecycle**: The critical path for workspace operations involves:
  - Workspace Manager
  - Image Builder
  - Kubernetes
  - Workspace Daemon
  - Supervisor

- **User Authentication**: The critical path for user authentication involves:
  - Auth Service
  - Dashboard
  - Proxy

## Known Challenges

- **Build System Complexity**: The Leeway build system has a learning curve
- **Component Dependencies**: Understanding dependencies between components can be challenging
- **Testing Environment**: Setting up proper testing environments for all components

## Tool Usage Patterns

- **VS Code**: Primary IDE for TypeScript development
- **GoLand/IntelliJ**: Often used for Go development
- **Docker**: Used for containerized development and testing
- **kubectl**: Used for interacting with Kubernetes clusters
- **Werft**: CI/CD system for automated builds and tests

## Documentation Patterns

- **README.md**: Each component should have a README explaining its purpose
- **API Documentation**: Generated from Protocol Buffer definitions
- **Architecture Documentation**: System-level documentation in various formats
- **Memory Bank Documentation**:
  - Component-specific documentation is stored in `memory-bank/components/` directory
  - Each component gets its own markdown file with detailed information about its purpose, architecture, and implementation
  - API components (with "*-api" suffix) should NOT be documented separately as they are typically just interface definitions
  - Component documentation should focus on the main service components that implement business logic
  - Documentation follows a consistent structure with sections for Overview, Purpose, Architecture, Key Features, etc.

## Evolution of Project Decisions

This section will be updated as I learn about how and why certain architectural and design decisions were made.

### Memory Bank Organization

- **Component Documentation**: The decision to create separate documentation files for each component in the `memory-bank/components/` directory was made to:
  1. Provide a clear, organized structure for component documentation
  2. Allow for detailed documentation of each component's purpose, architecture, and implementation
  3. Make it easier to find information about specific components
  4. Enable incremental updates to component documentation without affecting other files

- **API Component Exclusion**: The decision to exclude "*-api" components from separate documentation was made because:
  1. API components primarily contain interface definitions, not implementation logic
  2. The interfaces are typically documented within the main service component that implements them
  3. Documenting API components separately would create redundancy
  4. The focus should be on documenting the service components that implement business logic

## User Preferences

This section will be updated as I learn about specific user preferences for working with the codebase.

---

Note: This file will be continuously updated as I work with the Gitpod codebase and discover new patterns, preferences, and insights.
