// Copyright (c) 2023 Gitpod GmbH. All rights reserved.
// Licensed under the GNU Affero General Public License (AGPL).
// See License.AGPL.txt in the project root for license information.

package main

import (
	"fmt"
	"os"
	"path"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	contextPackage = protogen.GoImportPath("context")
	errorsPackage  = protogen.GoImportPath("errors")
	httpPackage    = protogen.GoImportPath("net/http")
	stringsPackage = protogen.GoImportPath("strings")
	connectPackage = protogen.GoImportPath("github.com/bufbuild/connect-go")
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		fmt.Fprintf(os.Stderr, "%v", gen.Files)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// generateFile generates a _ascii.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) {

	dir := path.Dir(file.GeneratedFilenamePrefix)
	name := path.Base(file.GeneratedFilenamePrefix)
	filename := path.Join(dir, "v1connect", name+".proxy.connect.go")

	if len(file.Services) == 0 {
		return
	}

	g := gen.NewGeneratedFile(filename, protogen.GoImportPath(path.Join(string(file.GoImportPath), string(file.GoPackageName))))
	g.P("// Code generated by protoc-gen-connect-proxy. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName+"connect")
	g.P()
	g.Import(file.GoImportPath)

	g.P()

	for _, service := range file.Services {
		// generate struct definition
		structName := "Proxy" + service.GoName + "Handler"

		g.P("var _ " + service.GoName + "Handler" + " = (*" + structName + ")(nil)")

		g.Annotate(structName, service.Location)

		g.P("type " + structName + " struct {")
		g.P("	Client " + g.QualifiedGoIdent(file.GoImportPath.Ident(service.GoName+"Client")))
		g.P("	Unimplemented" + service.GoName + "Handler")
		g.P("}")
		g.P()
		for _, method := range service.Methods {
			// for now we skip any non-unary methods
			// they inherit default not-implemented handling
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}

			// method signature
			g.P("func (s *" + structName + ") " + method.GoName + "(ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ", req *" + g.QualifiedGoIdent(connectPackage.Ident("Request")) + "[" +
				g.QualifiedGoIdent(method.Input.GoIdent) + "])" + "(*" + g.QualifiedGoIdent(connectPackage.Ident("Response")) + "[" + g.QualifiedGoIdent(method.Output.GoIdent) + "], error)" + "{")

			// method implementation
			g.P("	resp, err := s.Client." + method.GoName + "(ctx, req.Msg)")
			g.P("	if err != nil {")
			g.P("		// TODO(milan): Convert to correct status code")
			g.P("		return nil, err")
			g.P("	}")
			g.P()
			g.P("	return " + g.QualifiedGoIdent(connectPackage.Ident("NewResponse")) + "(resp), nil")
			g.P()

			// method end
			g.P("}")
			g.P()
		}

	}
}
