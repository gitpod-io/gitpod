// Copyright (c) 2023 Gitpod GmbH. All rights reserved.
// Licensed under the GNU Affero General Public License (AGPL).
// See License.AGPL.txt in the project root for license information.

package main

import (
	"fmt"
	"os"
	"path"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	contextPackage = protogen.GoImportPath("context")
	errorsPackage  = protogen.GoImportPath("errors")
	httpPackage    = protogen.GoImportPath("net/http")
	stringsPackage = protogen.GoImportPath("strings")
	connectPackage = protogen.GoImportPath("github.com/bufbuild/connect-go")
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		fmt.Fprintf(os.Stderr, "%v", gen.Files)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// generateFile generates a _ascii.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) {

	dir := path.Dir(file.GeneratedFilenamePrefix)
	name := path.Base(file.GeneratedFilenamePrefix)
	filename := path.Join(dir, "v1connect", name+".proxy.connect.go")

	// if len(file.Services) == 0 {
	// 	return
	// }

	g := gen.NewGeneratedFile(filename, protogen.GoImportPath(path.Join(string(file.GoImportPath), string(file.GoPackageName))))
	g.P("// Code generated by protoc-gen-connect-proxy. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName+"connect")
	g.P()
	// g.P("import (")
	// g.P(`	"context"`)
	// g.P(`	connect "github.com/bufbuild/connect-go"`)
	// g.P(")")
	g.Import(file.GoImportPath)
	// g.P(protogen.GoIdent{
	// 	GoName:       "context",
	// 	GoImportPath: "context",
	// })
	// g.P(protogen.GoIdent{
	// 	GoName:       "connect",
	// 	GoImportPath: "github.com/bufbuild/connect-go",
	// })
	// g.Import(protogen.GoImportPath("github.com/bufbuild/connect-go"))
	g.P()

	for _, service := range file.Services {
		// generate struct definition
		structName := "Proxy" + service.GoName + "Handler"
		g.Annotate(structName, service.Location)
		g.P("type " + structName + " struct {")
		g.P("	client " + g.QualifiedGoIdent(file.GoImportPath.Ident(service.GoName+"Client")))
		g.P("}")
		g.P()
		for _, method := range service.Methods {
			// method signature
			g.P("func (s *" + structName + ") " + method.GoName + "(ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context")) + ", req *" + g.QualifiedGoIdent(connectPackage.Ident("Request")) + "[" +
				g.QualifiedGoIdent(method.Input.GoIdent) + "])" + "(*" + g.QualifiedGoIdent(connectPackage.Ident("Response")) + "[" + g.QualifiedGoIdent(method.Output.GoIdent) + "], error)" + "{")

			// method implementation
			g.P("	resp, err := s.client." + method.GoName + "(ctx, req.Msg)")
			g.P("	if err != nil {")
			g.P("		// TODO(milan): Convert to correct status code")
			g.P("		return nil, err")
			g.P("	}")
			g.P()
			g.P("	return " + g.QualifiedGoIdent(connectPackage.Ident("NewResponse")) + "(resp), nil")
			g.P()

			// method end
			g.P("}")
			g.P()
		}

	}

	// import (
	// 	context "context"
	// 	errors "errors"
	// 	connect_go "github.com/bufbuild/connect-go"
	// 	v1 "github.com/gitpod-io/gitpod/components/public-api/go/experimental/v1"
	// 	http "net/http"
	// 	strings "strings"
	// )
}
