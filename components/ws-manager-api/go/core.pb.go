// Copyright (c) 2021 Gitpod GmbH. All rights reserved.
// Licensed under the GNU Affero General Public License (AGPL).
// See License-AGPL.txt in the project root for license information.

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: core.proto

package api

import (
	context "context"
	fmt "fmt"
	api "github.com/gitpod-io/gitpod/content-service/api"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type StopWorkspacePolicy int32

const (
	StopWorkspacePolicy_NORMALLY    StopWorkspacePolicy = 0
	StopWorkspacePolicy_IMMEDIATELY StopWorkspacePolicy = 1
)

var StopWorkspacePolicy_name = map[int32]string{
	0: "NORMALLY",
	1: "IMMEDIATELY",
}

var StopWorkspacePolicy_value = map[string]int32{
	"NORMALLY":    0,
	"IMMEDIATELY": 1,
}

func (x StopWorkspacePolicy) String() string {
	return proto.EnumName(StopWorkspacePolicy_name, int32(x))
}

func (StopWorkspacePolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{0}
}

type AdmissionLevel int32

const (
	// WORKSPACE_ADMIT_OWNER_ONLY means the workspace can only be accessed using the owner token
	AdmissionLevel_ADMIT_OWNER_ONLY AdmissionLevel = 0
	// WORKSPACE_ADMIT_EVERYONE means the workspace (including ports) can be accessed by everyone.
	AdmissionLevel_ADMIT_EVERYONE AdmissionLevel = 1
)

var AdmissionLevel_name = map[int32]string{
	0: "ADMIT_OWNER_ONLY",
	1: "ADMIT_EVERYONE",
}

var AdmissionLevel_value = map[string]int32{
	"ADMIT_OWNER_ONLY": 0,
	"ADMIT_EVERYONE":   1,
}

func (x AdmissionLevel) String() string {
	return proto.EnumName(AdmissionLevel_name, int32(x))
}

func (AdmissionLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{1}
}

// PortVisibility defines who may access a workspace port which is guarded by an authentication in the proxy
type PortVisibility int32

const (
	// private (default) means the port is accessible by the workspace owner only, unless the workspace's admission is
	// set to everyone.
	PortVisibility_PORT_VISIBILITY_PRIVATE PortVisibility = 0
	// public means the port is accessible by everybody using the workspace port URL
	PortVisibility_PORT_VISIBILITY_PUBLIC PortVisibility = 1
)

var PortVisibility_name = map[int32]string{
	0: "PORT_VISIBILITY_PRIVATE",
	1: "PORT_VISIBILITY_PUBLIC",
}

var PortVisibility_value = map[string]int32{
	"PORT_VISIBILITY_PRIVATE": 0,
	"PORT_VISIBILITY_PUBLIC":  1,
}

func (x PortVisibility) String() string {
	return proto.EnumName(PortVisibility_name, int32(x))
}

func (PortVisibility) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{2}
}

// WorkspaceConditionBool is a trinary bool: true/false/empty
type WorkspaceConditionBool int32

const (
	WorkspaceConditionBool_FALSE WorkspaceConditionBool = 0
	WorkspaceConditionBool_TRUE  WorkspaceConditionBool = 1
	WorkspaceConditionBool_EMPTY WorkspaceConditionBool = 2
)

var WorkspaceConditionBool_name = map[int32]string{
	0: "FALSE",
	1: "TRUE",
	2: "EMPTY",
}

var WorkspaceConditionBool_value = map[string]int32{
	"FALSE": 0,
	"TRUE":  1,
	"EMPTY": 2,
}

func (x WorkspaceConditionBool) String() string {
	return proto.EnumName(WorkspaceConditionBool_name, int32(x))
}

func (WorkspaceConditionBool) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{3}
}

// WorkspacePhase is a simple, high-level summary of where the workspace is in its lifecycle.
// The phase is not intended to be a comprehensive rollup of observations of the workspace state,
// nor is it intended to be a comprehensive state machine.
// (based on  https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase)
type WorkspacePhase int32

const (
	// Unknown indicates an issue within the workspace manager in that it cannot determine the actual phase of
	// a workspace. This phase is usually accompanied by an error.
	WorkspacePhase_UNKNOWN WorkspacePhase = 0
	// Pending means the workspace does not yet consume resources in the cluster, but rather is looking for
	// some space within the cluster. If for example the cluster needs to scale up to accomodate the
	// workspace, the workspace will be in Pending state until that happened.
	WorkspacePhase_PENDING WorkspacePhase = 1
	// Creating means the workspace is currently being created. That includes downloading the images required
	// to run the workspace over the network. The time spent in this phase varies widely and depends on the current
	// network speed, image size and cache states.
	WorkspacePhase_CREATING WorkspacePhase = 2
	// Initializing is the phase in which the workspace is executing the appropriate workspace initializer (e.g. Git
	// clone or backup download). After this phase one can expect the workspace to either be Running or Failed.
	WorkspacePhase_INITIALIZING WorkspacePhase = 3
	// Running means the workspace is able to actively perform work, either by serving a user through Theia,
	// or as a headless workspace.
	WorkspacePhase_RUNNING WorkspacePhase = 4
	// Interrupted is an exceptional state where the container should be running but is temporarily unavailable.
	// When in this state, we expect it to become running or stopping anytime soon.
	WorkspacePhase_INTERRUPTED WorkspacePhase = 7
	// Stopping means that the workspace is currently shutting down. It could go to stopped every moment.
	WorkspacePhase_STOPPING WorkspacePhase = 5
	// Stopped means the workspace ended regularly because it was shut down.
	WorkspacePhase_STOPPED WorkspacePhase = 6
)

var WorkspacePhase_name = map[int32]string{
	0: "UNKNOWN",
	1: "PENDING",
	2: "CREATING",
	3: "INITIALIZING",
	4: "RUNNING",
	7: "INTERRUPTED",
	5: "STOPPING",
	6: "STOPPED",
}

var WorkspacePhase_value = map[string]int32{
	"UNKNOWN":      0,
	"PENDING":      1,
	"CREATING":     2,
	"INITIALIZING": 3,
	"RUNNING":      4,
	"INTERRUPTED":  7,
	"STOPPING":     5,
	"STOPPED":      6,
}

func (x WorkspacePhase) String() string {
	return proto.EnumName(WorkspacePhase_name, int32(x))
}

func (WorkspacePhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{4}
}

// WorkspaceFeatureFlag enable non-standard behaviour in workspaces
type WorkspaceFeatureFlag int32

const (
	// NOOP feature flag is just here because I don't want privileged to be 0
	WorkspaceFeatureFlag_NOOP WorkspaceFeatureFlag = 0
	// RegistryFacade enables the image pull through the registry facade.
	// When this feature flag is set we do not mount Theia from the node but expect
	// it to be part of the image provided by the facade.
	WorkspaceFeatureFlag_REGISTRY_FACADE WorkspaceFeatureFlag = 3
	// FullWorkspaceBackup does away with the /workspace host mount. All workspace content lives
	// in the ephemeral container storage. We initlialize workspaces using content layer served by
	// the registry facade and back them up using regular "hardlink backups".
	//
	// This flag implies REGISTRY_FACADE
	WorkspaceFeatureFlag_FULL_WORKSPACE_BACKUP WorkspaceFeatureFlag = 4
	// FixedResources ensures this workspace is not subject to ws-daemon's dynamic resource limits.
	// In this sence it's akin to "guaranteed" (as compared to burstable) resources for workspaces.
	WorkspaceFeatureFlag_FIXED_RESOURCES WorkspaceFeatureFlag = 5
	// UserNamespace enables user namespace specific behaviour in the pod. It disables a host of
	// security features and - for now - should be considered equivalent to PRIVILEGED.
	//
	// TODO(cw): update this comment when userns are more secure.
	WorkspaceFeatureFlag_USER_NAMESPACE WorkspaceFeatureFlag = 6
)

var WorkspaceFeatureFlag_name = map[int32]string{
	0: "NOOP",
	3: "REGISTRY_FACADE",
	4: "FULL_WORKSPACE_BACKUP",
	5: "FIXED_RESOURCES",
	6: "USER_NAMESPACE",
}

var WorkspaceFeatureFlag_value = map[string]int32{
	"NOOP":                  0,
	"REGISTRY_FACADE":       3,
	"FULL_WORKSPACE_BACKUP": 4,
	"FIXED_RESOURCES":       5,
	"USER_NAMESPACE":        6,
}

func (x WorkspaceFeatureFlag) String() string {
	return proto.EnumName(WorkspaceFeatureFlag_name, int32(x))
}

func (WorkspaceFeatureFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{5}
}

// WorkspaceType specifies the purpose/use of a workspace. Different workspace types are handled differently by all parts of the system.
type WorkspaceType int32

const (
	// Regular workspaces are your off-the-mill workspaces intended for users. They are directly user-facing and hence are most important.
	WorkspaceType_REGULAR WorkspaceType = 0
	// Prebuild workspaces are workspaces used to pre-build the content of other workspaces. They run headless and have no direct user-interaction.
	WorkspaceType_PREBUILD WorkspaceType = 1
	// Probe workspaces are used to perform end-to-end health checks on the system. They require little to no resources, run headless and never
	// interact with users directly.
	WorkspaceType_PROBE WorkspaceType = 2
	// Ghost workspaces are placeholders that pre-scale a cluster for faster workspace startup. They request the same amount of resources
	// as a regular workspace, but run no actual load. They're removed at will to make space for an actual workspace.
	WorkspaceType_GHOST WorkspaceType = 3
)

var WorkspaceType_name = map[int32]string{
	0: "REGULAR",
	1: "PREBUILD",
	2: "PROBE",
	3: "GHOST",
}

var WorkspaceType_value = map[string]int32{
	"REGULAR":  0,
	"PREBUILD": 1,
	"PROBE":    2,
	"GHOST":    3,
}

func (x WorkspaceType) String() string {
	return proto.EnumName(WorkspaceType_name, int32(x))
}

func (WorkspaceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{6}
}

// GetWorkspacesRequest requests a list of running workspaces
type GetWorkspacesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetWorkspacesRequest) Reset()         { *m = GetWorkspacesRequest{} }
func (m *GetWorkspacesRequest) String() string { return proto.CompactTextString(m) }
func (*GetWorkspacesRequest) ProtoMessage()    {}
func (*GetWorkspacesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{0}
}

func (m *GetWorkspacesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetWorkspacesRequest.Unmarshal(m, b)
}
func (m *GetWorkspacesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetWorkspacesRequest.Marshal(b, m, deterministic)
}
func (m *GetWorkspacesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWorkspacesRequest.Merge(m, src)
}
func (m *GetWorkspacesRequest) XXX_Size() int {
	return xxx_messageInfo_GetWorkspacesRequest.Size(m)
}
func (m *GetWorkspacesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWorkspacesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetWorkspacesRequest proto.InternalMessageInfo

// GetWorkspacesResponse is the response to a get w
type GetWorkspacesResponse struct {
	// status are the status of all running workspaces
	Status               []*WorkspaceStatus `protobuf:"bytes,1,rep,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GetWorkspacesResponse) Reset()         { *m = GetWorkspacesResponse{} }
func (m *GetWorkspacesResponse) String() string { return proto.CompactTextString(m) }
func (*GetWorkspacesResponse) ProtoMessage()    {}
func (*GetWorkspacesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{1}
}

func (m *GetWorkspacesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetWorkspacesResponse.Unmarshal(m, b)
}
func (m *GetWorkspacesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetWorkspacesResponse.Marshal(b, m, deterministic)
}
func (m *GetWorkspacesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetWorkspacesResponse.Merge(m, src)
}
func (m *GetWorkspacesResponse) XXX_Size() int {
	return xxx_messageInfo_GetWorkspacesResponse.Size(m)
}
func (m *GetWorkspacesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetWorkspacesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetWorkspacesResponse proto.InternalMessageInfo

func (m *GetWorkspacesResponse) GetStatus() []*WorkspaceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// StartWorkspaceRequest requests that the workspace manager starts a workspace in its cluster
type StartWorkspaceRequest struct {
	// ID is a unique identifier of this workspace. No other workspace with the same name must be managed by this workspace manager
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// service_prefix is the unique ID/name that's prepended before the services associated with a workspace.
	// For example if the service_prefix is foobar there will be the services foobar-theia and foobar-ports.
	// If this field is empty the workspace ID becomes the service prefix.
	ServicePrefix string `protobuf:"bytes,2,opt,name=service_prefix,json=servicePrefix,proto3" json:"service_prefix,omitempty"`
	// Metadata is data associated with this workspace that's required for other parts of Gitpod to function
	Metadata *WorkspaceMetadata `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Spec is the configuration of the workspace that's required for the ws-manager to start the workspace
	Spec *StartWorkspaceSpec `protobuf:"bytes,4,opt,name=spec,proto3" json:"spec,omitempty"`
	// Type denots the kind of workspace we ought to start
	Type                 WorkspaceType `protobuf:"varint,6,opt,name=type,proto3,enum=wsman.WorkspaceType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *StartWorkspaceRequest) Reset()         { *m = StartWorkspaceRequest{} }
func (m *StartWorkspaceRequest) String() string { return proto.CompactTextString(m) }
func (*StartWorkspaceRequest) ProtoMessage()    {}
func (*StartWorkspaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{2}
}

func (m *StartWorkspaceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartWorkspaceRequest.Unmarshal(m, b)
}
func (m *StartWorkspaceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartWorkspaceRequest.Marshal(b, m, deterministic)
}
func (m *StartWorkspaceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartWorkspaceRequest.Merge(m, src)
}
func (m *StartWorkspaceRequest) XXX_Size() int {
	return xxx_messageInfo_StartWorkspaceRequest.Size(m)
}
func (m *StartWorkspaceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartWorkspaceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartWorkspaceRequest proto.InternalMessageInfo

func (m *StartWorkspaceRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StartWorkspaceRequest) GetServicePrefix() string {
	if m != nil {
		return m.ServicePrefix
	}
	return ""
}

func (m *StartWorkspaceRequest) GetMetadata() *WorkspaceMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *StartWorkspaceRequest) GetSpec() *StartWorkspaceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *StartWorkspaceRequest) GetType() WorkspaceType {
	if m != nil {
		return m.Type
	}
	return WorkspaceType_REGULAR
}

type StartWorkspaceResponse struct {
	// URL is the external URL of the workspace
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartWorkspaceResponse) Reset()         { *m = StartWorkspaceResponse{} }
func (m *StartWorkspaceResponse) String() string { return proto.CompactTextString(m) }
func (*StartWorkspaceResponse) ProtoMessage()    {}
func (*StartWorkspaceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{3}
}

func (m *StartWorkspaceResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartWorkspaceResponse.Unmarshal(m, b)
}
func (m *StartWorkspaceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartWorkspaceResponse.Marshal(b, m, deterministic)
}
func (m *StartWorkspaceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartWorkspaceResponse.Merge(m, src)
}
func (m *StartWorkspaceResponse) XXX_Size() int {
	return xxx_messageInfo_StartWorkspaceResponse.Size(m)
}
func (m *StartWorkspaceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartWorkspaceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartWorkspaceResponse proto.InternalMessageInfo

func (m *StartWorkspaceResponse) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// StopWorkspaceRequest requests that the workspace manager stops a workspace
type StopWorkspaceRequest struct {
	// ID is the unique identifier of the workspace to stop
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Policy determines how quickly a workspace will be stopped
	Policy               StopWorkspacePolicy `protobuf:"varint,2,opt,name=policy,proto3,enum=wsman.StopWorkspacePolicy" json:"policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *StopWorkspaceRequest) Reset()         { *m = StopWorkspaceRequest{} }
func (m *StopWorkspaceRequest) String() string { return proto.CompactTextString(m) }
func (*StopWorkspaceRequest) ProtoMessage()    {}
func (*StopWorkspaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{4}
}

func (m *StopWorkspaceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StopWorkspaceRequest.Unmarshal(m, b)
}
func (m *StopWorkspaceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StopWorkspaceRequest.Marshal(b, m, deterministic)
}
func (m *StopWorkspaceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopWorkspaceRequest.Merge(m, src)
}
func (m *StopWorkspaceRequest) XXX_Size() int {
	return xxx_messageInfo_StopWorkspaceRequest.Size(m)
}
func (m *StopWorkspaceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StopWorkspaceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StopWorkspaceRequest proto.InternalMessageInfo

func (m *StopWorkspaceRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *StopWorkspaceRequest) GetPolicy() StopWorkspacePolicy {
	if m != nil {
		return m.Policy
	}
	return StopWorkspacePolicy_NORMALLY
}

// StopWorkspaceResponse is the answer to a stop workspace request
type StopWorkspaceResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StopWorkspaceResponse) Reset()         { *m = StopWorkspaceResponse{} }
func (m *StopWorkspaceResponse) String() string { return proto.CompactTextString(m) }
func (*StopWorkspaceResponse) ProtoMessage()    {}
func (*StopWorkspaceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{5}
}

func (m *StopWorkspaceResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StopWorkspaceResponse.Unmarshal(m, b)
}
func (m *StopWorkspaceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StopWorkspaceResponse.Marshal(b, m, deterministic)
}
func (m *StopWorkspaceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopWorkspaceResponse.Merge(m, src)
}
func (m *StopWorkspaceResponse) XXX_Size() int {
	return xxx_messageInfo_StopWorkspaceResponse.Size(m)
}
func (m *StopWorkspaceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StopWorkspaceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StopWorkspaceResponse proto.InternalMessageInfo

// DescribeWorkspaceRequest requests the status of a workspace
type DescribeWorkspaceRequest struct {
	// ID is the unique identifier of the workspace to describe
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DescribeWorkspaceRequest) Reset()         { *m = DescribeWorkspaceRequest{} }
func (m *DescribeWorkspaceRequest) String() string { return proto.CompactTextString(m) }
func (*DescribeWorkspaceRequest) ProtoMessage()    {}
func (*DescribeWorkspaceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{6}
}

func (m *DescribeWorkspaceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DescribeWorkspaceRequest.Unmarshal(m, b)
}
func (m *DescribeWorkspaceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DescribeWorkspaceRequest.Marshal(b, m, deterministic)
}
func (m *DescribeWorkspaceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescribeWorkspaceRequest.Merge(m, src)
}
func (m *DescribeWorkspaceRequest) XXX_Size() int {
	return xxx_messageInfo_DescribeWorkspaceRequest.Size(m)
}
func (m *DescribeWorkspaceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DescribeWorkspaceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DescribeWorkspaceRequest proto.InternalMessageInfo

func (m *DescribeWorkspaceRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// DescribeWorkspaceResponse is the answer to a workspace description request
type DescribeWorkspaceResponse struct {
	Status *WorkspaceStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// LastActivity is the time when the workspace was last marked active - ISO8601 formated
	LastActivity         string   `protobuf:"bytes,2,opt,name=lastActivity,proto3" json:"lastActivity,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DescribeWorkspaceResponse) Reset()         { *m = DescribeWorkspaceResponse{} }
func (m *DescribeWorkspaceResponse) String() string { return proto.CompactTextString(m) }
func (*DescribeWorkspaceResponse) ProtoMessage()    {}
func (*DescribeWorkspaceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{7}
}

func (m *DescribeWorkspaceResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DescribeWorkspaceResponse.Unmarshal(m, b)
}
func (m *DescribeWorkspaceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DescribeWorkspaceResponse.Marshal(b, m, deterministic)
}
func (m *DescribeWorkspaceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescribeWorkspaceResponse.Merge(m, src)
}
func (m *DescribeWorkspaceResponse) XXX_Size() int {
	return xxx_messageInfo_DescribeWorkspaceResponse.Size(m)
}
func (m *DescribeWorkspaceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DescribeWorkspaceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DescribeWorkspaceResponse proto.InternalMessageInfo

func (m *DescribeWorkspaceResponse) GetStatus() *WorkspaceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *DescribeWorkspaceResponse) GetLastActivity() string {
	if m != nil {
		return m.LastActivity
	}
	return ""
}

// SubscribeRequest requests to be notified whenever the workspace status changes
type SubscribeRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SubscribeRequest) Reset()         { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()    {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{8}
}

func (m *SubscribeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeRequest.Unmarshal(m, b)
}
func (m *SubscribeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeRequest.Marshal(b, m, deterministic)
}
func (m *SubscribeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeRequest.Merge(m, src)
}
func (m *SubscribeRequest) XXX_Size() int {
	return xxx_messageInfo_SubscribeRequest.Size(m)
}
func (m *SubscribeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeRequest proto.InternalMessageInfo

// SubscribeResponse notifies a client when a workspace's status changes
type SubscribeResponse struct {
	// Types that are valid to be assigned to Payload:
	//	*SubscribeResponse_Status
	//	*SubscribeResponse_Log
	Payload              isSubscribeResponse_Payload `protobuf_oneof:"payload"`
	Header               map[string]string           `protobuf:"bytes,3,rep,name=header,proto3" json:"header,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *SubscribeResponse) Reset()         { *m = SubscribeResponse{} }
func (m *SubscribeResponse) String() string { return proto.CompactTextString(m) }
func (*SubscribeResponse) ProtoMessage()    {}
func (*SubscribeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{9}
}

func (m *SubscribeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SubscribeResponse.Unmarshal(m, b)
}
func (m *SubscribeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SubscribeResponse.Marshal(b, m, deterministic)
}
func (m *SubscribeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeResponse.Merge(m, src)
}
func (m *SubscribeResponse) XXX_Size() int {
	return xxx_messageInfo_SubscribeResponse.Size(m)
}
func (m *SubscribeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeResponse proto.InternalMessageInfo

type isSubscribeResponse_Payload interface {
	isSubscribeResponse_Payload()
}

type SubscribeResponse_Status struct {
	Status *WorkspaceStatus `protobuf:"bytes,1,opt,name=status,proto3,oneof"`
}

type SubscribeResponse_Log struct {
	Log *WorkspaceLogMessage `protobuf:"bytes,2,opt,name=log,proto3,oneof"`
}

func (*SubscribeResponse_Status) isSubscribeResponse_Payload() {}

func (*SubscribeResponse_Log) isSubscribeResponse_Payload() {}

func (m *SubscribeResponse) GetPayload() isSubscribeResponse_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *SubscribeResponse) GetStatus() *WorkspaceStatus {
	if x, ok := m.GetPayload().(*SubscribeResponse_Status); ok {
		return x.Status
	}
	return nil
}

func (m *SubscribeResponse) GetLog() *WorkspaceLogMessage {
	if x, ok := m.GetPayload().(*SubscribeResponse_Log); ok {
		return x.Log
	}
	return nil
}

func (m *SubscribeResponse) GetHeader() map[string]string {
	if m != nil {
		return m.Header
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SubscribeResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SubscribeResponse_Status)(nil),
		(*SubscribeResponse_Log)(nil),
	}
}

// MarkActiveRequest marks a workspace as still in use
type MarkActiveRequest struct {
	// id is the ID of the workspace
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// closed marks a workspace as closed which will shorten its timeout
	Closed               bool     `protobuf:"varint,2,opt,name=closed,proto3" json:"closed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkActiveRequest) Reset()         { *m = MarkActiveRequest{} }
func (m *MarkActiveRequest) String() string { return proto.CompactTextString(m) }
func (*MarkActiveRequest) ProtoMessage()    {}
func (*MarkActiveRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{10}
}

func (m *MarkActiveRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MarkActiveRequest.Unmarshal(m, b)
}
func (m *MarkActiveRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MarkActiveRequest.Marshal(b, m, deterministic)
}
func (m *MarkActiveRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkActiveRequest.Merge(m, src)
}
func (m *MarkActiveRequest) XXX_Size() int {
	return xxx_messageInfo_MarkActiveRequest.Size(m)
}
func (m *MarkActiveRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkActiveRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MarkActiveRequest proto.InternalMessageInfo

func (m *MarkActiveRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MarkActiveRequest) GetClosed() bool {
	if m != nil {
		return m.Closed
	}
	return false
}

// MarkActiveResponse is the answer to a mark workspace active request
type MarkActiveResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MarkActiveResponse) Reset()         { *m = MarkActiveResponse{} }
func (m *MarkActiveResponse) String() string { return proto.CompactTextString(m) }
func (*MarkActiveResponse) ProtoMessage()    {}
func (*MarkActiveResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{11}
}

func (m *MarkActiveResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MarkActiveResponse.Unmarshal(m, b)
}
func (m *MarkActiveResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MarkActiveResponse.Marshal(b, m, deterministic)
}
func (m *MarkActiveResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarkActiveResponse.Merge(m, src)
}
func (m *MarkActiveResponse) XXX_Size() int {
	return xxx_messageInfo_MarkActiveResponse.Size(m)
}
func (m *MarkActiveResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MarkActiveResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MarkActiveResponse proto.InternalMessageInfo

// SetTimeoutRequest configures the timeout of a workspace
type SetTimeoutRequest struct {
	// id is the ID of the workspace
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// duration is the new timeout duration. Must be a valid Go duration (see https://golang.org/pkg/time/#ParseDuration)
	Duration             string   `protobuf:"bytes,2,opt,name=duration,proto3" json:"duration,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetTimeoutRequest) Reset()         { *m = SetTimeoutRequest{} }
func (m *SetTimeoutRequest) String() string { return proto.CompactTextString(m) }
func (*SetTimeoutRequest) ProtoMessage()    {}
func (*SetTimeoutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{12}
}

func (m *SetTimeoutRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetTimeoutRequest.Unmarshal(m, b)
}
func (m *SetTimeoutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetTimeoutRequest.Marshal(b, m, deterministic)
}
func (m *SetTimeoutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetTimeoutRequest.Merge(m, src)
}
func (m *SetTimeoutRequest) XXX_Size() int {
	return xxx_messageInfo_SetTimeoutRequest.Size(m)
}
func (m *SetTimeoutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetTimeoutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetTimeoutRequest proto.InternalMessageInfo

func (m *SetTimeoutRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SetTimeoutRequest) GetDuration() string {
	if m != nil {
		return m.Duration
	}
	return ""
}

// SetTimeoutResponse is the answer to a set timeout request
type SetTimeoutResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetTimeoutResponse) Reset()         { *m = SetTimeoutResponse{} }
func (m *SetTimeoutResponse) String() string { return proto.CompactTextString(m) }
func (*SetTimeoutResponse) ProtoMessage()    {}
func (*SetTimeoutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{13}
}

func (m *SetTimeoutResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SetTimeoutResponse.Unmarshal(m, b)
}
func (m *SetTimeoutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SetTimeoutResponse.Marshal(b, m, deterministic)
}
func (m *SetTimeoutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetTimeoutResponse.Merge(m, src)
}
func (m *SetTimeoutResponse) XXX_Size() int {
	return xxx_messageInfo_SetTimeoutResponse.Size(m)
}
func (m *SetTimeoutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetTimeoutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetTimeoutResponse proto.InternalMessageInfo

// ControlPortRequest exposes or un-exposes networking ports of a workspace
type ControlPortRequest struct {
	// ID is the unique identifier of the workspace whose port to control
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// expose controls whether to make the port publicly available or bar if from being accessible outside of the worksapce.
	// If true, the port will become publicly available, if false it will become inaccessible from outside the workspace.
	Expose bool `protobuf:"varint,2,opt,name=expose,proto3" json:"expose,omitempty"`
	// spec defines the port under control
	Spec                 *PortSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *ControlPortRequest) Reset()         { *m = ControlPortRequest{} }
func (m *ControlPortRequest) String() string { return proto.CompactTextString(m) }
func (*ControlPortRequest) ProtoMessage()    {}
func (*ControlPortRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{14}
}

func (m *ControlPortRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControlPortRequest.Unmarshal(m, b)
}
func (m *ControlPortRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControlPortRequest.Marshal(b, m, deterministic)
}
func (m *ControlPortRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlPortRequest.Merge(m, src)
}
func (m *ControlPortRequest) XXX_Size() int {
	return xxx_messageInfo_ControlPortRequest.Size(m)
}
func (m *ControlPortRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlPortRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ControlPortRequest proto.InternalMessageInfo

func (m *ControlPortRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ControlPortRequest) GetExpose() bool {
	if m != nil {
		return m.Expose
	}
	return false
}

func (m *ControlPortRequest) GetSpec() *PortSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

// ControlPortResponse is the answer to a workspace port control request
type ControlPortResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ControlPortResponse) Reset()         { *m = ControlPortResponse{} }
func (m *ControlPortResponse) String() string { return proto.CompactTextString(m) }
func (*ControlPortResponse) ProtoMessage()    {}
func (*ControlPortResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{15}
}

func (m *ControlPortResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControlPortResponse.Unmarshal(m, b)
}
func (m *ControlPortResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControlPortResponse.Marshal(b, m, deterministic)
}
func (m *ControlPortResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlPortResponse.Merge(m, src)
}
func (m *ControlPortResponse) XXX_Size() int {
	return xxx_messageInfo_ControlPortResponse.Size(m)
}
func (m *ControlPortResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlPortResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ControlPortResponse proto.InternalMessageInfo

// TakeSnapshotRequest creates a copy of the workspace content. This copy can be used to initialize a new workspace.
type TakeSnapshotRequest struct {
	// ID is the unique identifier of the workspace of which to take a snapshot
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TakeSnapshotRequest) Reset()         { *m = TakeSnapshotRequest{} }
func (m *TakeSnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*TakeSnapshotRequest) ProtoMessage()    {}
func (*TakeSnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{16}
}

func (m *TakeSnapshotRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TakeSnapshotRequest.Unmarshal(m, b)
}
func (m *TakeSnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TakeSnapshotRequest.Marshal(b, m, deterministic)
}
func (m *TakeSnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TakeSnapshotRequest.Merge(m, src)
}
func (m *TakeSnapshotRequest) XXX_Size() int {
	return xxx_messageInfo_TakeSnapshotRequest.Size(m)
}
func (m *TakeSnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TakeSnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TakeSnapshotRequest proto.InternalMessageInfo

func (m *TakeSnapshotRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// TakeSnapshotResponse is the answer to a take snapshot request
type TakeSnapshotResponse struct {
	// URL is the location of the snapshot encoded such that it can be passed back to a snapshot initializer.
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TakeSnapshotResponse) Reset()         { *m = TakeSnapshotResponse{} }
func (m *TakeSnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*TakeSnapshotResponse) ProtoMessage()    {}
func (*TakeSnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{17}
}

func (m *TakeSnapshotResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TakeSnapshotResponse.Unmarshal(m, b)
}
func (m *TakeSnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TakeSnapshotResponse.Marshal(b, m, deterministic)
}
func (m *TakeSnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TakeSnapshotResponse.Merge(m, src)
}
func (m *TakeSnapshotResponse) XXX_Size() int {
	return xxx_messageInfo_TakeSnapshotResponse.Size(m)
}
func (m *TakeSnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TakeSnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TakeSnapshotResponse proto.InternalMessageInfo

func (m *TakeSnapshotResponse) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// ControlAdmissionRequest controls the admission of users to a workspace
type ControlAdmissionRequest struct {
	// ID is the unique identifier of the workspace whoose admission to control
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// level is the new workspace admission level
	Level                AdmissionLevel `protobuf:"varint,2,opt,name=level,proto3,enum=wsman.AdmissionLevel" json:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ControlAdmissionRequest) Reset()         { *m = ControlAdmissionRequest{} }
func (m *ControlAdmissionRequest) String() string { return proto.CompactTextString(m) }
func (*ControlAdmissionRequest) ProtoMessage()    {}
func (*ControlAdmissionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{18}
}

func (m *ControlAdmissionRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControlAdmissionRequest.Unmarshal(m, b)
}
func (m *ControlAdmissionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControlAdmissionRequest.Marshal(b, m, deterministic)
}
func (m *ControlAdmissionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlAdmissionRequest.Merge(m, src)
}
func (m *ControlAdmissionRequest) XXX_Size() int {
	return xxx_messageInfo_ControlAdmissionRequest.Size(m)
}
func (m *ControlAdmissionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlAdmissionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ControlAdmissionRequest proto.InternalMessageInfo

func (m *ControlAdmissionRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ControlAdmissionRequest) GetLevel() AdmissionLevel {
	if m != nil {
		return m.Level
	}
	return AdmissionLevel_ADMIT_OWNER_ONLY
}

type ControlAdmissionResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ControlAdmissionResponse) Reset()         { *m = ControlAdmissionResponse{} }
func (m *ControlAdmissionResponse) String() string { return proto.CompactTextString(m) }
func (*ControlAdmissionResponse) ProtoMessage()    {}
func (*ControlAdmissionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{19}
}

func (m *ControlAdmissionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ControlAdmissionResponse.Unmarshal(m, b)
}
func (m *ControlAdmissionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ControlAdmissionResponse.Marshal(b, m, deterministic)
}
func (m *ControlAdmissionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlAdmissionResponse.Merge(m, src)
}
func (m *ControlAdmissionResponse) XXX_Size() int {
	return xxx_messageInfo_ControlAdmissionResponse.Size(m)
}
func (m *ControlAdmissionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlAdmissionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ControlAdmissionResponse proto.InternalMessageInfo

// WorkspaceStatus describes a workspace status
type WorkspaceStatus struct {
	// ID is the unique identifier of the workspace
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Metadata is data associated with this workspace that's required for other parts of Gitpod to function
	Metadata *WorkspaceMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Spec is the workspace spec during runtime
	Spec *WorkspaceSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec,omitempty"`
	// the phase of a workspace is a simple, high-level summary of where the workspace is in its lifecycle
	Phase WorkspacePhase `protobuf:"varint,4,opt,name=phase,proto3,enum=wsman.WorkspacePhase" json:"phase,omitempty"`
	// conditions detail the current state of the workspace
	Conditions *WorkspaceConditions `protobuf:"bytes,5,opt,name=conditions,proto3" json:"conditions,omitempty"`
	// message is an optional human-readable message detailing the current phase
	Message string `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
	// repo details the Git working copy status of the workspace.
	// Note: this is a best-effort field and more often than not will not be present. Its absence does not
	// indicate the absence of a working copy.
	Repo *api.GitStatus `protobuf:"bytes,7,opt,name=repo,proto3" json:"repo,omitempty"`
	// runtime contains information about the workspace's runtime environment
	Runtime *WorkspaceRuntimeInfo `protobuf:"bytes,8,opt,name=runtime,proto3" json:"runtime,omitempty"`
	// auth provides authentication information about the workspace. This info is primarily used by ws-proxy.
	Auth                 *WorkspaceAuthentication `protobuf:"bytes,9,opt,name=auth,proto3" json:"auth,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *WorkspaceStatus) Reset()         { *m = WorkspaceStatus{} }
func (m *WorkspaceStatus) String() string { return proto.CompactTextString(m) }
func (*WorkspaceStatus) ProtoMessage()    {}
func (*WorkspaceStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{20}
}

func (m *WorkspaceStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkspaceStatus.Unmarshal(m, b)
}
func (m *WorkspaceStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkspaceStatus.Marshal(b, m, deterministic)
}
func (m *WorkspaceStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkspaceStatus.Merge(m, src)
}
func (m *WorkspaceStatus) XXX_Size() int {
	return xxx_messageInfo_WorkspaceStatus.Size(m)
}
func (m *WorkspaceStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkspaceStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkspaceStatus proto.InternalMessageInfo

func (m *WorkspaceStatus) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *WorkspaceStatus) GetMetadata() *WorkspaceMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *WorkspaceStatus) GetSpec() *WorkspaceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *WorkspaceStatus) GetPhase() WorkspacePhase {
	if m != nil {
		return m.Phase
	}
	return WorkspacePhase_UNKNOWN
}

func (m *WorkspaceStatus) GetConditions() *WorkspaceConditions {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *WorkspaceStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *WorkspaceStatus) GetRepo() *api.GitStatus {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *WorkspaceStatus) GetRuntime() *WorkspaceRuntimeInfo {
	if m != nil {
		return m.Runtime
	}
	return nil
}

func (m *WorkspaceStatus) GetAuth() *WorkspaceAuthentication {
	if m != nil {
		return m.Auth
	}
	return nil
}

// WorkspaceSpec is the specification of a workspace at runtime
type WorkspaceSpec struct {
	// workspace_image is the name of the Docker image this workspace runs
	WorkspaceImage string `protobuf:"bytes,1,opt,name=workspace_image,json=workspaceImage,proto3" json:"workspace_image,omitempty"`
	// ide_image is the name of the Docker image used as IDE
	IdeImage string `protobuf:"bytes,2,opt,name=ide_image,json=ideImage,proto3" json:"ide_image,omitempty"`
	// headless marks this workspace a headless one - headless workspaces are not intended for users but for automation
	Headless bool `protobuf:"varint,3,opt,name=headless,proto3" json:"headless,omitempty"`
	// URL is the external URL of the workspace
	Url string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	// exposed_ports lists all ports which this workspace has exposed to the outside world
	ExposedPorts []*PortSpec `protobuf:"bytes,5,rep,name=exposed_ports,json=exposedPorts,proto3" json:"exposed_ports,omitempty"`
	// workspace type denotes what kind of workspace this is, e.g. if it's user-facing, prebuilding content or probing the service
	Type WorkspaceType `protobuf:"varint,6,opt,name=type,proto3,enum=wsman.WorkspaceType" json:"type,omitempty"`
	// The intervals in which a heartbeat must be received for the workspace not to time out
	Timeout              string   `protobuf:"bytes,7,opt,name=timeout,proto3" json:"timeout,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkspaceSpec) Reset()         { *m = WorkspaceSpec{} }
func (m *WorkspaceSpec) String() string { return proto.CompactTextString(m) }
func (*WorkspaceSpec) ProtoMessage()    {}
func (*WorkspaceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{21}
}

func (m *WorkspaceSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkspaceSpec.Unmarshal(m, b)
}
func (m *WorkspaceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkspaceSpec.Marshal(b, m, deterministic)
}
func (m *WorkspaceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkspaceSpec.Merge(m, src)
}
func (m *WorkspaceSpec) XXX_Size() int {
	return xxx_messageInfo_WorkspaceSpec.Size(m)
}
func (m *WorkspaceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkspaceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_WorkspaceSpec proto.InternalMessageInfo

func (m *WorkspaceSpec) GetWorkspaceImage() string {
	if m != nil {
		return m.WorkspaceImage
	}
	return ""
}

func (m *WorkspaceSpec) GetIdeImage() string {
	if m != nil {
		return m.IdeImage
	}
	return ""
}

func (m *WorkspaceSpec) GetHeadless() bool {
	if m != nil {
		return m.Headless
	}
	return false
}

func (m *WorkspaceSpec) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *WorkspaceSpec) GetExposedPorts() []*PortSpec {
	if m != nil {
		return m.ExposedPorts
	}
	return nil
}

func (m *WorkspaceSpec) GetType() WorkspaceType {
	if m != nil {
		return m.Type
	}
	return WorkspaceType_REGULAR
}

func (m *WorkspaceSpec) GetTimeout() string {
	if m != nil {
		return m.Timeout
	}
	return ""
}

// PortSpec describes a networking port exposed on a workspace
type PortSpec struct {
	// port is the outward-facing port
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	// target is the inward-facing target port
	Target uint32 `protobuf:"varint,2,opt,name=target,proto3" json:"target,omitempty"`
	// visibility defines the visibility of the port
	Visibility PortVisibility `protobuf:"varint,3,opt,name=visibility,proto3,enum=wsman.PortVisibility" json:"visibility,omitempty"`
	// url is the public-facing URL this port is available at
	Url                  string   `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PortSpec) Reset()         { *m = PortSpec{} }
func (m *PortSpec) String() string { return proto.CompactTextString(m) }
func (*PortSpec) ProtoMessage()    {}
func (*PortSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{22}
}

func (m *PortSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PortSpec.Unmarshal(m, b)
}
func (m *PortSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PortSpec.Marshal(b, m, deterministic)
}
func (m *PortSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PortSpec.Merge(m, src)
}
func (m *PortSpec) XXX_Size() int {
	return xxx_messageInfo_PortSpec.Size(m)
}
func (m *PortSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_PortSpec.DiscardUnknown(m)
}

var xxx_messageInfo_PortSpec proto.InternalMessageInfo

func (m *PortSpec) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *PortSpec) GetTarget() uint32 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *PortSpec) GetVisibility() PortVisibility {
	if m != nil {
		return m.Visibility
	}
	return PortVisibility_PORT_VISIBILITY_PRIVATE
}

func (m *PortSpec) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// WorkspaceCondition gives more detailed information as to the state of the workspace. Which condition actually
// has a value depends on the phase the workspace is in.
type WorkspaceConditions struct {
	// failed contains the reason the workspace failed to operate. If this field is empty, the workspace has not failed.
	Failed string `protobuf:"bytes,1,opt,name=failed,proto3" json:"failed,omitempty"`
	// timeout contains the reason the workspace has timed out. If this field is empty, the workspace has not timed out.
	Timeout string `protobuf:"bytes,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// pulling_images marks if the workspace is currently pulling its images. This condition can only be set during PhaseCreating
	PullingImages WorkspaceConditionBool `protobuf:"varint,3,opt,name=pulling_images,json=pullingImages,proto3,enum=wsman.WorkspaceConditionBool" json:"pulling_images,omitempty"`
	// service_exists denotes if the workspace theia-/ports- services exist. This condition will be true if either of the two services exist.
	ServiceExists WorkspaceConditionBool `protobuf:"varint,4,opt,name=service_exists,json=serviceExists,proto3,enum=wsman.WorkspaceConditionBool" json:"service_exists,omitempty"`
	// snapshot contains a snapshot URL if a snapshot was produced prior to shutting the workspace down. This condition is only used for headless workspaces.
	Snapshot string `protobuf:"bytes,5,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	// final_backup_complete determines if the last state of the workspace has been backed up to remote storage.
	// Once this is true, a new workspace with the same ID will be able to use this backup.
	FinalBackupComplete WorkspaceConditionBool `protobuf:"varint,6,opt,name=final_backup_complete,json=finalBackupComplete,proto3,enum=wsman.WorkspaceConditionBool" json:"final_backup_complete,omitempty"`
	// deployed indicates if a workspace container is currently deployed. If this condition is false, there is no means for the user to alter the workspace content.
	Deployed WorkspaceConditionBool `protobuf:"varint,7,opt,name=deployed,proto3,enum=wsman.WorkspaceConditionBool" json:"deployed,omitempty"`
	// network_not_ready indicates if a workspace container is currently experiencing a network problem.
	NetworkNotReady WorkspaceConditionBool `protobuf:"varint,8,opt,name=network_not_ready,json=networkNotReady,proto3,enum=wsman.WorkspaceConditionBool" json:"network_not_ready,omitempty"`
	// first_user_activity is the time when MarkActive was first called on the workspace
	FirstUserActivity    *timestamp.Timestamp `protobuf:"bytes,9,opt,name=first_user_activity,json=firstUserActivity,proto3" json:"first_user_activity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *WorkspaceConditions) Reset()         { *m = WorkspaceConditions{} }
func (m *WorkspaceConditions) String() string { return proto.CompactTextString(m) }
func (*WorkspaceConditions) ProtoMessage()    {}
func (*WorkspaceConditions) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{23}
}

func (m *WorkspaceConditions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkspaceConditions.Unmarshal(m, b)
}
func (m *WorkspaceConditions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkspaceConditions.Marshal(b, m, deterministic)
}
func (m *WorkspaceConditions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkspaceConditions.Merge(m, src)
}
func (m *WorkspaceConditions) XXX_Size() int {
	return xxx_messageInfo_WorkspaceConditions.Size(m)
}
func (m *WorkspaceConditions) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkspaceConditions.DiscardUnknown(m)
}

var xxx_messageInfo_WorkspaceConditions proto.InternalMessageInfo

func (m *WorkspaceConditions) GetFailed() string {
	if m != nil {
		return m.Failed
	}
	return ""
}

func (m *WorkspaceConditions) GetTimeout() string {
	if m != nil {
		return m.Timeout
	}
	return ""
}

func (m *WorkspaceConditions) GetPullingImages() WorkspaceConditionBool {
	if m != nil {
		return m.PullingImages
	}
	return WorkspaceConditionBool_FALSE
}

func (m *WorkspaceConditions) GetServiceExists() WorkspaceConditionBool {
	if m != nil {
		return m.ServiceExists
	}
	return WorkspaceConditionBool_FALSE
}

func (m *WorkspaceConditions) GetSnapshot() string {
	if m != nil {
		return m.Snapshot
	}
	return ""
}

func (m *WorkspaceConditions) GetFinalBackupComplete() WorkspaceConditionBool {
	if m != nil {
		return m.FinalBackupComplete
	}
	return WorkspaceConditionBool_FALSE
}

func (m *WorkspaceConditions) GetDeployed() WorkspaceConditionBool {
	if m != nil {
		return m.Deployed
	}
	return WorkspaceConditionBool_FALSE
}

func (m *WorkspaceConditions) GetNetworkNotReady() WorkspaceConditionBool {
	if m != nil {
		return m.NetworkNotReady
	}
	return WorkspaceConditionBool_FALSE
}

func (m *WorkspaceConditions) GetFirstUserActivity() *timestamp.Timestamp {
	if m != nil {
		return m.FirstUserActivity
	}
	return nil
}

// WorkspaceMetadata is data associated with a workspace that's required for other parts of the system to function
type WorkspaceMetadata struct {
	// owner is the ID of the Gitpod user to whom we'll bill this workspace and who we consider responsible for its content
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// meta_id is the workspace ID of this currently running workspace instance on the "meta pool" side
	MetaId string `protobuf:"bytes,2,opt,name=meta_id,json=metaId,proto3" json:"meta_id,omitempty"`
	// started_at is the time when this workspace was started. Consider this field read-only, i.e. setting in a request will have no effect.
	StartedAt            *timestamp.Timestamp `protobuf:"bytes,3,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *WorkspaceMetadata) Reset()         { *m = WorkspaceMetadata{} }
func (m *WorkspaceMetadata) String() string { return proto.CompactTextString(m) }
func (*WorkspaceMetadata) ProtoMessage()    {}
func (*WorkspaceMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{24}
}

func (m *WorkspaceMetadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkspaceMetadata.Unmarshal(m, b)
}
func (m *WorkspaceMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkspaceMetadata.Marshal(b, m, deterministic)
}
func (m *WorkspaceMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkspaceMetadata.Merge(m, src)
}
func (m *WorkspaceMetadata) XXX_Size() int {
	return xxx_messageInfo_WorkspaceMetadata.Size(m)
}
func (m *WorkspaceMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkspaceMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_WorkspaceMetadata proto.InternalMessageInfo

func (m *WorkspaceMetadata) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *WorkspaceMetadata) GetMetaId() string {
	if m != nil {
		return m.MetaId
	}
	return ""
}

func (m *WorkspaceMetadata) GetStartedAt() *timestamp.Timestamp {
	if m != nil {
		return m.StartedAt
	}
	return nil
}

// WorkspaceRuntimeInfo details the workspace's runtime, e.g. executing system, node other information
// about the environment the workspace runs in. This information serves a diangostic purpose only and
// should not be directly acted upon.
type WorkspaceRuntimeInfo struct {
	// node_name is the name of the node the workspace runs on
	NodeName             string   `protobuf:"bytes,1,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkspaceRuntimeInfo) Reset()         { *m = WorkspaceRuntimeInfo{} }
func (m *WorkspaceRuntimeInfo) String() string { return proto.CompactTextString(m) }
func (*WorkspaceRuntimeInfo) ProtoMessage()    {}
func (*WorkspaceRuntimeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{25}
}

func (m *WorkspaceRuntimeInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkspaceRuntimeInfo.Unmarshal(m, b)
}
func (m *WorkspaceRuntimeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkspaceRuntimeInfo.Marshal(b, m, deterministic)
}
func (m *WorkspaceRuntimeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkspaceRuntimeInfo.Merge(m, src)
}
func (m *WorkspaceRuntimeInfo) XXX_Size() int {
	return xxx_messageInfo_WorkspaceRuntimeInfo.Size(m)
}
func (m *WorkspaceRuntimeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkspaceRuntimeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WorkspaceRuntimeInfo proto.InternalMessageInfo

func (m *WorkspaceRuntimeInfo) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

// WorkspaceAuthentication contains authentication information used by ws-proxy to allow/deny access to
// workspaces and their ports.
type WorkspaceAuthentication struct {
	// Admission describes who can access the workspace and its ports.
	Admission AdmissionLevel `protobuf:"varint,1,opt,name=admission,proto3,enum=wsman.AdmissionLevel" json:"admission,omitempty"`
	// Owner token is the token one needs to access the workspace. Its presence is checked by ws-proxy.
	OwnerToken           string   `protobuf:"bytes,2,opt,name=owner_token,json=ownerToken,proto3" json:"owner_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkspaceAuthentication) Reset()         { *m = WorkspaceAuthentication{} }
func (m *WorkspaceAuthentication) String() string { return proto.CompactTextString(m) }
func (*WorkspaceAuthentication) ProtoMessage()    {}
func (*WorkspaceAuthentication) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{26}
}

func (m *WorkspaceAuthentication) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkspaceAuthentication.Unmarshal(m, b)
}
func (m *WorkspaceAuthentication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkspaceAuthentication.Marshal(b, m, deterministic)
}
func (m *WorkspaceAuthentication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkspaceAuthentication.Merge(m, src)
}
func (m *WorkspaceAuthentication) XXX_Size() int {
	return xxx_messageInfo_WorkspaceAuthentication.Size(m)
}
func (m *WorkspaceAuthentication) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkspaceAuthentication.DiscardUnknown(m)
}

var xxx_messageInfo_WorkspaceAuthentication proto.InternalMessageInfo

func (m *WorkspaceAuthentication) GetAdmission() AdmissionLevel {
	if m != nil {
		return m.Admission
	}
	return AdmissionLevel_ADMIT_OWNER_ONLY
}

func (m *WorkspaceAuthentication) GetOwnerToken() string {
	if m != nil {
		return m.OwnerToken
	}
	return ""
}

// StartWorkspaceSpec specifies the configuration of a workspace for a workspace start
type StartWorkspaceSpec struct {
	// workspace_image is the Docker image name of the workspace container
	WorkspaceImage string `protobuf:"bytes,1,opt,name=workspace_image,json=workspaceImage,proto3" json:"workspace_image,omitempty"`
	// ide_image is the Docker image name of the IDE image
	IdeImage string `protobuf:"bytes,2,opt,name=ide_image,json=ideImage,proto3" json:"ide_image,omitempty"`
	// feature_flags provide a means for starting variants of workspaces (e.g. a privileged one)
	FeatureFlags []WorkspaceFeatureFlag `protobuf:"varint,3,rep,packed,name=feature_flags,json=featureFlags,proto3,enum=wsman.WorkspaceFeatureFlag" json:"feature_flags,omitempty"`
	// initializer configures how the workspace is to be initialized
	Initializer *api.WorkspaceInitializer `protobuf:"bytes,4,opt,name=initializer,proto3" json:"initializer,omitempty"`
	// ports is the set of ports which ought to be exposed to the internet
	Ports []*PortSpec `protobuf:"bytes,5,rep,name=ports,proto3" json:"ports,omitempty"`
	// envvars are user-defined environment variables which ought to be available in the workspace
	Envvars []*EnvironmentVariable `protobuf:"bytes,6,rep,name=envvars,proto3" json:"envvars,omitempty"`
	// checkout_location describes where the code has been checked out to
	CheckoutLocation string `protobuf:"bytes,7,opt,name=checkout_location,json=checkoutLocation,proto3" json:"checkout_location,omitempty"`
	// workspace_location describes where the workspace root of Theia will be
	WorkspaceLocation string `protobuf:"bytes,8,opt,name=workspace_location,json=workspaceLocation,proto3" json:"workspace_location,omitempty"`
	// Git configures the Git user in the workspace
	Git *GitSpec `protobuf:"bytes,9,opt,name=git,proto3" json:"git,omitempty"`
	// timeout optionally sets a custom workspace timeout
	Timeout string `protobuf:"bytes,10,opt,name=timeout,proto3" json:"timeout,omitempty"`
	// admission controlls who can access the workspace and its ports.
	Admission            AdmissionLevel `protobuf:"varint,11,opt,name=admission,proto3,enum=wsman.AdmissionLevel" json:"admission,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *StartWorkspaceSpec) Reset()         { *m = StartWorkspaceSpec{} }
func (m *StartWorkspaceSpec) String() string { return proto.CompactTextString(m) }
func (*StartWorkspaceSpec) ProtoMessage()    {}
func (*StartWorkspaceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{27}
}

func (m *StartWorkspaceSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StartWorkspaceSpec.Unmarshal(m, b)
}
func (m *StartWorkspaceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StartWorkspaceSpec.Marshal(b, m, deterministic)
}
func (m *StartWorkspaceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartWorkspaceSpec.Merge(m, src)
}
func (m *StartWorkspaceSpec) XXX_Size() int {
	return xxx_messageInfo_StartWorkspaceSpec.Size(m)
}
func (m *StartWorkspaceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_StartWorkspaceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_StartWorkspaceSpec proto.InternalMessageInfo

func (m *StartWorkspaceSpec) GetWorkspaceImage() string {
	if m != nil {
		return m.WorkspaceImage
	}
	return ""
}

func (m *StartWorkspaceSpec) GetIdeImage() string {
	if m != nil {
		return m.IdeImage
	}
	return ""
}

func (m *StartWorkspaceSpec) GetFeatureFlags() []WorkspaceFeatureFlag {
	if m != nil {
		return m.FeatureFlags
	}
	return nil
}

func (m *StartWorkspaceSpec) GetInitializer() *api.WorkspaceInitializer {
	if m != nil {
		return m.Initializer
	}
	return nil
}

func (m *StartWorkspaceSpec) GetPorts() []*PortSpec {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *StartWorkspaceSpec) GetEnvvars() []*EnvironmentVariable {
	if m != nil {
		return m.Envvars
	}
	return nil
}

func (m *StartWorkspaceSpec) GetCheckoutLocation() string {
	if m != nil {
		return m.CheckoutLocation
	}
	return ""
}

func (m *StartWorkspaceSpec) GetWorkspaceLocation() string {
	if m != nil {
		return m.WorkspaceLocation
	}
	return ""
}

func (m *StartWorkspaceSpec) GetGit() *GitSpec {
	if m != nil {
		return m.Git
	}
	return nil
}

func (m *StartWorkspaceSpec) GetTimeout() string {
	if m != nil {
		return m.Timeout
	}
	return ""
}

func (m *StartWorkspaceSpec) GetAdmission() AdmissionLevel {
	if m != nil {
		return m.Admission
	}
	return AdmissionLevel_ADMIT_OWNER_ONLY
}

// GitSpec configures the Git available within the workspace
type GitSpec struct {
	// The Git username
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// The Git email address
	Email                string   `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GitSpec) Reset()         { *m = GitSpec{} }
func (m *GitSpec) String() string { return proto.CompactTextString(m) }
func (*GitSpec) ProtoMessage()    {}
func (*GitSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{28}
}

func (m *GitSpec) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GitSpec.Unmarshal(m, b)
}
func (m *GitSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GitSpec.Marshal(b, m, deterministic)
}
func (m *GitSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GitSpec.Merge(m, src)
}
func (m *GitSpec) XXX_Size() int {
	return xxx_messageInfo_GitSpec.Size(m)
}
func (m *GitSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_GitSpec.DiscardUnknown(m)
}

var xxx_messageInfo_GitSpec proto.InternalMessageInfo

func (m *GitSpec) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *GitSpec) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

// EnvironmentVariable describes an env var as key/value pair
type EnvironmentVariable struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvironmentVariable) Reset()         { *m = EnvironmentVariable{} }
func (m *EnvironmentVariable) String() string { return proto.CompactTextString(m) }
func (*EnvironmentVariable) ProtoMessage()    {}
func (*EnvironmentVariable) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{29}
}

func (m *EnvironmentVariable) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvironmentVariable.Unmarshal(m, b)
}
func (m *EnvironmentVariable) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvironmentVariable.Marshal(b, m, deterministic)
}
func (m *EnvironmentVariable) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvironmentVariable.Merge(m, src)
}
func (m *EnvironmentVariable) XXX_Size() int {
	return xxx_messageInfo_EnvironmentVariable.Size(m)
}
func (m *EnvironmentVariable) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvironmentVariable.DiscardUnknown(m)
}

var xxx_messageInfo_EnvironmentVariable proto.InternalMessageInfo

func (m *EnvironmentVariable) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EnvironmentVariable) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// HeadlessWorkspaceEvent is a log statement issued by a headless workspace
type WorkspaceLogMessage struct {
	// ID is the ID of the workspace this event eminated from
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// metadata is the workspace metadata
	Metadata *WorkspaceMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Message is the payload associated with this event
	Message              string   `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WorkspaceLogMessage) Reset()         { *m = WorkspaceLogMessage{} }
func (m *WorkspaceLogMessage) String() string { return proto.CompactTextString(m) }
func (*WorkspaceLogMessage) ProtoMessage()    {}
func (*WorkspaceLogMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f7e43720d1edc0fe, []int{30}
}

func (m *WorkspaceLogMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_WorkspaceLogMessage.Unmarshal(m, b)
}
func (m *WorkspaceLogMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_WorkspaceLogMessage.Marshal(b, m, deterministic)
}
func (m *WorkspaceLogMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkspaceLogMessage.Merge(m, src)
}
func (m *WorkspaceLogMessage) XXX_Size() int {
	return xxx_messageInfo_WorkspaceLogMessage.Size(m)
}
func (m *WorkspaceLogMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkspaceLogMessage.DiscardUnknown(m)
}

var xxx_messageInfo_WorkspaceLogMessage proto.InternalMessageInfo

func (m *WorkspaceLogMessage) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *WorkspaceLogMessage) GetMetadata() *WorkspaceMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *WorkspaceLogMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterEnum("wsman.StopWorkspacePolicy", StopWorkspacePolicy_name, StopWorkspacePolicy_value)
	proto.RegisterEnum("wsman.AdmissionLevel", AdmissionLevel_name, AdmissionLevel_value)
	proto.RegisterEnum("wsman.PortVisibility", PortVisibility_name, PortVisibility_value)
	proto.RegisterEnum("wsman.WorkspaceConditionBool", WorkspaceConditionBool_name, WorkspaceConditionBool_value)
	proto.RegisterEnum("wsman.WorkspacePhase", WorkspacePhase_name, WorkspacePhase_value)
	proto.RegisterEnum("wsman.WorkspaceFeatureFlag", WorkspaceFeatureFlag_name, WorkspaceFeatureFlag_value)
	proto.RegisterEnum("wsman.WorkspaceType", WorkspaceType_name, WorkspaceType_value)
	proto.RegisterType((*GetWorkspacesRequest)(nil), "wsman.GetWorkspacesRequest")
	proto.RegisterType((*GetWorkspacesResponse)(nil), "wsman.GetWorkspacesResponse")
	proto.RegisterType((*StartWorkspaceRequest)(nil), "wsman.StartWorkspaceRequest")
	proto.RegisterType((*StartWorkspaceResponse)(nil), "wsman.StartWorkspaceResponse")
	proto.RegisterType((*StopWorkspaceRequest)(nil), "wsman.StopWorkspaceRequest")
	proto.RegisterType((*StopWorkspaceResponse)(nil), "wsman.StopWorkspaceResponse")
	proto.RegisterType((*DescribeWorkspaceRequest)(nil), "wsman.DescribeWorkspaceRequest")
	proto.RegisterType((*DescribeWorkspaceResponse)(nil), "wsman.DescribeWorkspaceResponse")
	proto.RegisterType((*SubscribeRequest)(nil), "wsman.SubscribeRequest")
	proto.RegisterType((*SubscribeResponse)(nil), "wsman.SubscribeResponse")
	proto.RegisterMapType((map[string]string)(nil), "wsman.SubscribeResponse.HeaderEntry")
	proto.RegisterType((*MarkActiveRequest)(nil), "wsman.MarkActiveRequest")
	proto.RegisterType((*MarkActiveResponse)(nil), "wsman.MarkActiveResponse")
	proto.RegisterType((*SetTimeoutRequest)(nil), "wsman.SetTimeoutRequest")
	proto.RegisterType((*SetTimeoutResponse)(nil), "wsman.SetTimeoutResponse")
	proto.RegisterType((*ControlPortRequest)(nil), "wsman.ControlPortRequest")
	proto.RegisterType((*ControlPortResponse)(nil), "wsman.ControlPortResponse")
	proto.RegisterType((*TakeSnapshotRequest)(nil), "wsman.TakeSnapshotRequest")
	proto.RegisterType((*TakeSnapshotResponse)(nil), "wsman.TakeSnapshotResponse")
	proto.RegisterType((*ControlAdmissionRequest)(nil), "wsman.ControlAdmissionRequest")
	proto.RegisterType((*ControlAdmissionResponse)(nil), "wsman.ControlAdmissionResponse")
	proto.RegisterType((*WorkspaceStatus)(nil), "wsman.WorkspaceStatus")
	proto.RegisterType((*WorkspaceSpec)(nil), "wsman.WorkspaceSpec")
	proto.RegisterType((*PortSpec)(nil), "wsman.PortSpec")
	proto.RegisterType((*WorkspaceConditions)(nil), "wsman.WorkspaceConditions")
	proto.RegisterType((*WorkspaceMetadata)(nil), "wsman.WorkspaceMetadata")
	proto.RegisterType((*WorkspaceRuntimeInfo)(nil), "wsman.WorkspaceRuntimeInfo")
	proto.RegisterType((*WorkspaceAuthentication)(nil), "wsman.WorkspaceAuthentication")
	proto.RegisterType((*StartWorkspaceSpec)(nil), "wsman.StartWorkspaceSpec")
	proto.RegisterType((*GitSpec)(nil), "wsman.GitSpec")
	proto.RegisterType((*EnvironmentVariable)(nil), "wsman.EnvironmentVariable")
	proto.RegisterType((*WorkspaceLogMessage)(nil), "wsman.WorkspaceLogMessage")
}

func init() {
	proto.RegisterFile("core.proto", fileDescriptor_f7e43720d1edc0fe)
}

var fileDescriptor_f7e43720d1edc0fe = []byte{
	// 2067 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xdd, 0x6f, 0xdb, 0xc8,
	0x11, 0xb7, 0x3e, 0x2c, 0x4b, 0x63, 0x5b, 0xa6, 0xd7, 0x5f, 0x8a, 0x92, 0xbb, 0x18, 0xec, 0x05,
	0x35, 0x9c, 0xda, 0x3e, 0x38, 0x39, 0xe0, 0x92, 0x2b, 0x70, 0x27, 0xcb, 0xb4, 0xc3, 0x8b, 0x2c,
	0xa9, 0x2b, 0xc9, 0x39, 0xe7, 0x85, 0x58, 0x8b, 0x6b, 0x99, 0x30, 0x45, 0xb2, 0xe4, 0xca, 0x8e,
	0x0a, 0x14, 0x7d, 0x28, 0xfa, 0x5a, 0xa0, 0x40, 0x9f, 0xfb, 0xcf, 0xf5, 0xaf, 0xe8, 0x43, 0x81,
	0xc3, 0x2e, 0x97, 0x14, 0xf5, 0x15, 0xe7, 0xe1, 0xde, 0x38, 0x3b, 0xbf, 0x99, 0xdd, 0x9d, 0x9d,
	0xf9, 0xed, 0x2c, 0x01, 0xba, 0xae, 0x4f, 0x0f, 0x3d, 0xdf, 0x65, 0x2e, 0x5a, 0x7c, 0x08, 0xfa,
	0xc4, 0x29, 0xbf, 0xe8, 0xba, 0x0e, 0xa3, 0x0e, 0x3b, 0x08, 0xa8, 0x7f, 0x6f, 0x75, 0xe9, 0x01,
	0xf1, 0xac, 0x23, 0xcb, 0xb1, 0x98, 0x45, 0x6c, 0xeb, 0x2f, 0xd4, 0x0f, 0xd1, 0xe5, 0xe7, 0x3d,
	0xd7, 0xed, 0xd9, 0xf4, 0x48, 0x48, 0xd7, 0x83, 0x9b, 0x23, 0x66, 0xf5, 0x69, 0xc0, 0x48, 0xdf,
	0x0b, 0x01, 0xea, 0x36, 0x6c, 0x9e, 0x53, 0xf6, 0xc1, 0xf5, 0xef, 0x02, 0x8f, 0x74, 0x69, 0x80,
	0xe9, 0x9f, 0x07, 0x34, 0x60, 0xea, 0x39, 0x6c, 0x4d, 0x8c, 0x07, 0x9e, 0xeb, 0x04, 0x14, 0x1d,
	0x42, 0x2e, 0x60, 0x84, 0x0d, 0x82, 0x52, 0x6a, 0x37, 0xb3, 0xb7, 0x7c, 0xbc, 0x7d, 0x28, 0x16,
	0x74, 0x18, 0x43, 0x5b, 0x42, 0x8b, 0x25, 0x4a, 0xfd, 0x6f, 0x0a, 0xb6, 0x5a, 0x8c, 0xf8, 0x23,
	0x5f, 0x72, 0x0a, 0x54, 0x84, 0xb4, 0x65, 0x96, 0x52, 0xbb, 0xa9, 0xbd, 0x02, 0x4e, 0x5b, 0x26,
	0x7a, 0x01, 0x45, 0xb9, 0x19, 0xc3, 0xf3, 0xe9, 0x8d, 0xf5, 0xa9, 0x94, 0x16, 0xba, 0x55, 0x39,
	0xda, 0x14, 0x83, 0xe8, 0x35, 0xe4, 0xfb, 0x94, 0x11, 0x93, 0x30, 0x52, 0xca, 0xec, 0xa6, 0xf6,
	0x96, 0x8f, 0x4b, 0x93, 0x4b, 0xb8, 0x90, 0x7a, 0x1c, 0x23, 0xd1, 0x01, 0x64, 0x03, 0x8f, 0x76,
	0x4b, 0x59, 0x61, 0xf1, 0x44, 0x5a, 0x8c, 0x2f, 0xac, 0xe5, 0xd1, 0x2e, 0x16, 0x30, 0xb4, 0x07,
	0x59, 0x36, 0xf4, 0x68, 0x29, 0xb7, 0x9b, 0xda, 0x2b, 0x1e, 0x6f, 0x4e, 0x4e, 0xd0, 0x1e, 0x7a,
	0x14, 0x0b, 0xc4, 0xcf, 0xd9, 0xfc, 0xa2, 0x92, 0x53, 0xf7, 0x61, 0x7b, 0x72, 0x93, 0x32, 0x5e,
	0x0a, 0x64, 0x06, 0xbe, 0x2d, 0xb7, 0xc9, 0x3f, 0xd5, 0x8f, 0xb0, 0xd9, 0x62, 0xae, 0xf7, 0x68,
	0x3c, 0x8e, 0x21, 0xe7, 0xb9, 0xb6, 0xd5, 0x1d, 0x8a, 0x38, 0x14, 0x8f, 0xcb, 0xf1, 0xa2, 0x13,
	0xc6, 0x4d, 0x81, 0xc0, 0x12, 0xa9, 0xee, 0xf0, 0x60, 0x8f, 0xf9, 0x0e, 0x97, 0xa1, 0xee, 0x43,
	0xe9, 0x94, 0x06, 0x5d, 0xdf, 0xba, 0xa6, 0x8f, 0x4d, 0xac, 0xba, 0xf0, 0x64, 0x06, 0x76, 0xc6,
	0xf9, 0xa7, 0x1e, 0x3f, 0x7f, 0xa4, 0xc2, 0x8a, 0x4d, 0x02, 0x56, 0xe9, 0x32, 0xeb, 0xde, 0x62,
	0x43, 0x79, 0xa6, 0x63, 0x63, 0x2a, 0x02, 0xa5, 0x35, 0xb8, 0x0e, 0x67, 0x8c, 0x12, 0xf0, 0x7f,
	0x29, 0x58, 0x4f, 0x0c, 0xca, 0xd9, 0xbf, 0xfd, 0xb2, 0xd9, 0xdf, 0x2d, 0xc4, 0xf3, 0x1f, 0x42,
	0xc6, 0x76, 0x7b, 0x62, 0xda, 0xe5, 0x38, 0x84, 0x31, 0xbc, 0xe6, 0xf6, 0x2e, 0x68, 0x10, 0x90,
	0x1e, 0x7d, 0xb7, 0x80, 0x39, 0x10, 0xfd, 0x11, 0x72, 0xb7, 0x94, 0x98, 0xd4, 0x2f, 0x65, 0x44,
	0x7e, 0x7f, 0x13, 0x45, 0x7d, 0x72, 0x2d, 0x87, 0xef, 0x04, 0x4c, 0x73, 0x98, 0x3f, 0xc4, 0xd2,
	0xa6, 0xfc, 0x06, 0x96, 0x13, 0xc3, 0xfc, 0xf0, 0xef, 0xe8, 0x30, 0x3a, 0xfc, 0x3b, 0x3a, 0x44,
	0x9b, 0xb0, 0x78, 0x4f, 0xec, 0x01, 0x95, 0x71, 0x08, 0x85, 0xb7, 0xe9, 0xef, 0x53, 0x27, 0x05,
	0x58, 0xf2, 0xc8, 0xd0, 0x76, 0x89, 0xa9, 0xfe, 0x00, 0xeb, 0x17, 0xc4, 0xbf, 0x13, 0xf1, 0x99,
	0x9b, 0x1e, 0xdb, 0x90, 0xeb, 0xda, 0x6e, 0x40, 0x4d, 0xe1, 0x2a, 0x8f, 0xa5, 0xa4, 0x6e, 0x02,
	0x4a, 0x1a, 0xcb, 0xf3, 0xff, 0x11, 0xd6, 0x5b, 0x94, 0xb5, 0xad, 0x3e, 0x75, 0x07, 0x6c, 0x9e,
	0xcb, 0x32, 0xe4, 0xcd, 0x81, 0x4f, 0x98, 0xe5, 0x3a, 0x72, 0x7d, 0xb1, 0xcc, 0xdd, 0x26, 0x1d,
	0x48, 0xb7, 0x04, 0x50, 0xd5, 0x75, 0x98, 0xef, 0xda, 0x4d, 0xd7, 0x67, 0x9f, 0x59, 0x2a, 0xfd,
	0xe4, 0xb9, 0x01, 0x8d, 0x96, 0x1a, 0x4a, 0xe8, 0x77, 0xb2, 0x28, 0xc3, 0x32, 0x5e, 0x93, 0x91,
	0xe6, 0x9e, 0x46, 0xa5, 0xa8, 0x6e, 0xc1, 0xc6, 0xd8, 0x14, 0x72, 0xe6, 0x17, 0xb0, 0xd1, 0x26,
	0x77, 0xb4, 0xe5, 0x10, 0x2f, 0xb8, 0x75, 0xe7, 0x4d, 0xad, 0xee, 0xc1, 0xe6, 0x38, 0x6c, 0x6e,
	0x59, 0x5e, 0xc2, 0x8e, 0x9c, 0xa7, 0x62, 0xf6, 0xad, 0x20, 0xb0, 0x5c, 0x67, 0xde, 0x7e, 0x5e,
	0xc2, 0xa2, 0x4d, 0xef, 0xa9, 0x2d, 0x0b, 0x73, 0x4b, 0x2e, 0x3c, 0xb6, 0xab, 0x71, 0x25, 0x0e,
	0x31, 0x6a, 0x19, 0x4a, 0xd3, 0x7e, 0xe5, 0x26, 0xfe, 0x93, 0x81, 0xb5, 0x89, 0xd4, 0x9d, 0x9a,
	0x2c, 0xc9, 0x77, 0xe9, 0x2f, 0xe6, 0xbb, 0xbd, 0xb1, 0xd0, 0x4e, 0x11, 0x58, 0x82, 0xea, 0x5e,
	0xc2, 0xa2, 0x77, 0x4b, 0x02, 0x2a, 0xa8, 0x71, 0xb4, 0x99, 0x11, 0xc3, 0x70, 0x25, 0x0e, 0x31,
	0xe8, 0x2d, 0xbf, 0x8b, 0x1c, 0xd3, 0xe2, 0x29, 0x11, 0x94, 0x16, 0x67, 0x17, 0x55, 0x35, 0x46,
	0xe0, 0x04, 0x1a, 0x95, 0x60, 0xa9, 0x1f, 0xd6, 0x9a, 0xa0, 0xd5, 0x02, 0x8e, 0x44, 0x4e, 0xce,
	0x3e, 0xf5, 0xdc, 0xd2, 0x92, 0x24, 0x67, 0x79, 0xb7, 0x49, 0xde, 0x3f, 0x3c, 0xb7, 0x98, 0x24,
	0x15, 0x01, 0x43, 0xdf, 0xc1, 0x92, 0x3f, 0x70, 0xf8, 0x4d, 0x56, 0xca, 0x0b, 0x8b, 0xa7, 0x93,
	0x2b, 0xc0, 0xa1, 0x5a, 0x77, 0x6e, 0x5c, 0x1c, 0x61, 0xd1, 0x31, 0x64, 0xc9, 0x80, 0xdd, 0x96,
	0x0a, 0xc2, 0xe6, 0xeb, 0x49, 0x9b, 0xca, 0x80, 0xdd, 0x52, 0x87, 0x59, 0x5d, 0x91, 0xef, 0x58,
	0x60, 0xd5, 0xff, 0xa7, 0x60, 0x75, 0x2c, 0x68, 0xe8, 0xf7, 0xb0, 0xf6, 0x10, 0x0d, 0x18, 0x56,
	0x9f, 0xef, 0x26, 0x3c, 0xab, 0x62, 0x3c, 0xac, 0xf3, 0x51, 0xf4, 0x14, 0x0a, 0x96, 0x19, 0x41,
	0x64, 0x35, 0x59, 0xa6, 0x54, 0x96, 0x21, 0xcf, 0x19, 0xc3, 0xa6, 0x41, 0x20, 0x8e, 0x28, 0x8f,
	0x63, 0x39, 0x4a, 0xcd, 0x6c, 0x9c, 0x9a, 0xe8, 0x35, 0xac, 0x86, 0x15, 0x63, 0x1a, 0x9e, 0xeb,
	0x33, 0x1e, 0xf8, 0xcc, 0xac, 0x82, 0x59, 0x91, 0x28, 0x3e, 0x10, 0x7c, 0xf9, 0x1d, 0xc6, 0x4f,
	0x86, 0x85, 0x85, 0x2d, 0x8e, 0xa0, 0x80, 0x23, 0x51, 0xfd, 0x1b, 0xe4, 0x23, 0xef, 0x08, 0x41,
	0x96, 0xcf, 0x2e, 0xb6, 0xbb, 0x8a, 0xc5, 0x37, 0xaf, 0x6c, 0x46, 0xfc, 0x1e, 0x65, 0x62, 0x87,
	0xab, 0x58, 0x4a, 0xe8, 0x3b, 0x80, 0x7b, 0x2b, 0xb0, 0xae, 0x2d, 0x9b, 0x73, 0x7e, 0x66, 0x2c,
	0xb3, 0xb8, 0xc3, 0xcb, 0x58, 0x89, 0x13, 0xc0, 0xe9, 0xad, 0xab, 0xff, 0xce, 0xc2, 0xc6, 0x8c,
	0xc4, 0xe2, 0x13, 0xdf, 0x10, 0xcb, 0xa6, 0x51, 0xa5, 0x48, 0x29, 0xb9, 0x95, 0xf4, 0xd8, 0x56,
	0xd0, 0x29, 0x14, 0xbd, 0x81, 0x6d, 0x5b, 0x4e, 0x2f, 0x3c, 0x93, 0x40, 0x2e, 0xeb, 0xab, 0xb9,
	0xe9, 0x7b, 0xe2, 0xba, 0x36, 0x5e, 0x95, 0x46, 0xe2, 0xdc, 0x02, 0xee, 0x25, 0x6a, 0x52, 0xe8,
	0x27, 0x2b, 0x60, 0x81, 0x2c, 0x9b, 0xc7, 0xbc, 0x48, 0x23, 0x4d, 0xd8, 0xf0, 0xe3, 0x0f, 0x24,
	0x23, 0x89, 0x22, 0x2a, 0xe0, 0x58, 0x46, 0x7f, 0x82, 0xad, 0x1b, 0xcb, 0x21, 0xb6, 0x71, 0x4d,
	0xba, 0x77, 0x03, 0xcf, 0xe8, 0xba, 0x7d, 0xcf, 0xa6, 0x2c, 0x3a, 0xc7, 0x47, 0x26, 0xda, 0x10,
	0xb6, 0x27, 0xc2, 0xb4, 0x2a, 0x2d, 0xd1, 0x1b, 0xc8, 0x9b, 0xd4, 0xb3, 0xdd, 0x21, 0x35, 0xc5,
	0x01, 0x3f, 0xea, 0x25, 0x86, 0x23, 0x1d, 0xd6, 0x1d, 0xca, 0x78, 0x6a, 0x1b, 0x8e, 0xcb, 0x0c,
	0x9f, 0x12, 0x73, 0x28, 0xaa, 0xee, 0x51, 0x1f, 0x6b, 0xd2, 0xae, 0xce, 0x59, 0x97, 0x98, 0x43,
	0xf4, 0x33, 0x6c, 0xdc, 0x58, 0x7e, 0xc0, 0x8c, 0x41, 0x40, 0x7d, 0x83, 0x44, 0x0d, 0x41, 0x41,
	0x92, 0x48, 0xd8, 0xa9, 0x1e, 0x46, 0x9d, 0xea, 0x61, 0x3b, 0xea, 0x54, 0xf1, 0xba, 0x30, 0xeb,
	0x04, 0xd4, 0x8f, 0x3b, 0x86, 0xbf, 0xc2, 0xfa, 0x14, 0xfb, 0xf1, 0xbb, 0xd5, 0x7d, 0x70, 0xa8,
	0x2f, 0x53, 0x22, 0x14, 0xd0, 0x0e, 0xa7, 0x1d, 0x46, 0x0c, 0xcb, 0x94, 0x19, 0x91, 0xe3, 0xa2,
	0x6e, 0xa2, 0x37, 0x00, 0x01, 0xef, 0xd9, 0xa8, 0x69, 0x10, 0x26, 0x89, 0xf2, 0x73, 0xcb, 0x28,
	0x48, 0x74, 0x85, 0xa9, 0xaf, 0x60, 0x73, 0x16, 0xd7, 0xf0, 0x9a, 0x77, 0x5c, 0x93, 0x1a, 0x0e,
	0xe9, 0x47, 0xb4, 0x90, 0xe7, 0x03, 0x75, 0xd2, 0xa7, 0xaa, 0x0b, 0x3b, 0x73, 0xc8, 0x06, 0xbd,
	0x82, 0x02, 0x89, 0x2e, 0x07, 0x61, 0x37, 0xf7, 0x52, 0x19, 0xe1, 0xd0, 0x73, 0x58, 0x16, 0x3b,
	0x34, 0x98, 0x7b, 0x47, 0xa3, 0x0b, 0x1b, 0xc4, 0x50, 0x9b, 0x8f, 0xa8, 0xff, 0xcc, 0x02, 0x9a,
	0xee, 0x70, 0x7f, 0x23, 0x06, 0xfb, 0x09, 0x56, 0x6f, 0x28, 0x61, 0x03, 0x9f, 0x1a, 0x37, 0x36,
	0xe9, 0x05, 0xa2, 0x5d, 0x2a, 0x4e, 0x53, 0xf1, 0x59, 0x08, 0x3a, 0xb3, 0x49, 0x0f, 0xaf, 0xdc,
	0x8c, 0x84, 0x00, 0x9d, 0xc1, 0x72, 0xe2, 0xc1, 0x22, 0x3b, 0xf3, 0x6f, 0x26, 0xc9, 0x3f, 0x76,
	0xa4, 0x8f, 0xb0, 0x38, 0x69, 0x88, 0x5e, 0xc0, 0xe2, 0x67, 0x59, 0x31, 0xd4, 0xa2, 0xd7, 0xb0,
	0x44, 0x9d, 0xfb, 0x7b, 0xe2, 0x07, 0xa5, 0x9c, 0x00, 0x46, 0xf7, 0x96, 0xe6, 0xdc, 0x5b, 0xbe,
	0xeb, 0xf4, 0xa9, 0xc3, 0x2e, 0x89, 0x6f, 0x91, 0x6b, 0x9b, 0xe2, 0x08, 0x8a, 0x5e, 0xc2, 0x7a,
	0xf7, 0x96, 0x76, 0xef, 0xdc, 0x01, 0x33, 0x6c, 0x37, 0x3c, 0x2e, 0x49, 0x92, 0x4a, 0xa4, 0xa8,
	0xc9, 0x71, 0x74, 0x00, 0x68, 0x14, 0xd9, 0x18, 0x9d, 0x17, 0xe8, 0xf5, 0x87, 0x51, 0xcf, 0x29,
	0xe1, 0xbb, 0x90, 0xe9, 0x59, 0x4c, 0x16, 0x40, 0x51, 0xae, 0x86, 0x5f, 0x76, 0x7c, 0xd5, 0x5c,
	0x95, 0x64, 0x33, 0x18, 0x67, 0xb3, 0xb1, 0x8c, 0x59, 0xfe, 0xb2, 0x8c, 0x51, 0x7f, 0x80, 0x25,
	0xe9, 0x9e, 0x33, 0x10, 0x2f, 0xc3, 0x64, 0xa2, 0x46, 0x32, 0xaf, 0x23, 0xda, 0x27, 0x96, 0x1d,
	0xf5, 0xa8, 0x42, 0x50, 0x7f, 0x84, 0x8d, 0x19, 0x91, 0xe2, 0xb7, 0x42, 0xc2, 0x49, 0x36, 0x72,
	0x30, 0xdd, 0xe4, 0xaa, 0x83, 0x04, 0x93, 0x8f, 0xfa, 0xee, 0xdf, 0xa8, 0xdf, 0x49, 0x34, 0x17,
	0xd9, 0xb1, 0xe6, 0x62, 0xff, 0x35, 0x6c, 0xcc, 0x78, 0x31, 0xa1, 0x15, 0xc8, 0xd7, 0x1b, 0xf8,
	0xa2, 0x52, 0xab, 0x5d, 0x29, 0x0b, 0x68, 0x0d, 0x96, 0xf5, 0x8b, 0x0b, 0xed, 0x54, 0xaf, 0xb4,
	0xb5, 0xda, 0x95, 0x92, 0xda, 0x7f, 0x0b, 0xc5, 0xf1, 0x38, 0xa2, 0x4d, 0x50, 0x2a, 0xa7, 0x17,
	0x7a, 0xdb, 0x68, 0x7c, 0xa8, 0x6b, 0xd8, 0x68, 0xd4, 0x85, 0x21, 0x82, 0x62, 0x38, 0xaa, 0x5d,
	0x6a, 0xf8, 0xaa, 0x51, 0xd7, 0x94, 0xd4, 0xbe, 0x0e, 0xc5, 0xf1, 0x3b, 0x0e, 0x3d, 0x85, 0x9d,
	0x66, 0x03, 0xb7, 0x8d, 0x4b, 0xbd, 0xa5, 0x9f, 0xe8, 0x35, 0xbd, 0x7d, 0x65, 0x34, 0xb1, 0x7e,
	0x59, 0x69, 0x6b, 0xca, 0x02, 0x2a, 0xc3, 0xf6, 0x94, 0xb2, 0x73, 0x52, 0xd3, 0xab, 0x4a, 0x6a,
	0xff, 0x7b, 0xd8, 0x9e, 0x4d, 0xaf, 0xa8, 0x00, 0x8b, 0x67, 0x95, 0x5a, 0x8b, 0x3b, 0xc8, 0x43,
	0xb6, 0x8d, 0x3b, 0x9a, 0x92, 0xe2, 0x83, 0xda, 0x45, 0xb3, 0x7d, 0xa5, 0xa4, 0xf7, 0xff, 0x9e,
	0x82, 0xe2, 0x78, 0x0f, 0x87, 0x96, 0x61, 0xa9, 0x53, 0x7f, 0x5f, 0x6f, 0x7c, 0xa8, 0x2b, 0x0b,
	0x5c, 0x68, 0x6a, 0xf5, 0x53, 0xbd, 0x7e, 0xae, 0xa4, 0x78, 0x30, 0xaa, 0x58, 0xab, 0xb4, 0xb9,
	0x94, 0x46, 0x0a, 0xac, 0xe8, 0x75, 0xbd, 0xad, 0x57, 0x6a, 0xfa, 0x47, 0x3e, 0x92, 0xe1, 0x60,
	0xdc, 0xa9, 0xd7, 0xb9, 0x90, 0x15, 0xb1, 0xaa, 0xb7, 0x35, 0x8c, 0x3b, 0xcd, 0xb6, 0x76, 0xaa,
	0x2c, 0x71, 0xeb, 0x56, 0xbb, 0xd1, 0x6c, 0x72, 0xf5, 0x22, 0xc7, 0x0a, 0x49, 0x3b, 0x55, 0x72,
	0xfb, 0xff, 0x48, 0x25, 0x98, 0x32, 0x41, 0x05, 0x7c, 0xcd, 0xf5, 0x46, 0xa3, 0xa9, 0x2c, 0xa0,
	0x0d, 0x58, 0xc3, 0xda, 0xb9, 0xde, 0x6a, 0xe3, 0x2b, 0xe3, 0xac, 0x52, 0xad, 0x9c, 0x6a, 0x4a,
	0x06, 0x3d, 0x81, 0xad, 0xb3, 0x4e, 0xad, 0x66, 0x7c, 0x68, 0xe0, 0xf7, 0xad, 0x66, 0xa5, 0xaa,
	0x19, 0x27, 0x95, 0xea, 0xfb, 0x4e, 0x53, 0xc9, 0x72, 0xfc, 0x99, 0xfe, 0x8b, 0x76, 0x6a, 0x60,
	0xad, 0xd5, 0xe8, 0xe0, 0xaa, 0xd6, 0x52, 0x16, 0xf9, 0x31, 0x74, 0x5a, 0x1a, 0x36, 0xea, 0x95,
	0x0b, 0x4d, 0xe0, 0x95, 0x9c, 0x9a, 0xcd, 0xa7, 0x94, 0x94, 0x9a, 0xcd, 0xa7, 0x95, 0xf4, 0xfe,
	0x4f, 0x89, 0x36, 0x8e, 0x37, 0x3e, 0x62, 0x47, 0xda, 0x79, 0xa7, 0x56, 0xc1, 0xca, 0x02, 0xdf,
	0x40, 0x13, 0x6b, 0x27, 0x1d, 0xbd, 0x76, 0x1a, 0x06, 0xb1, 0x89, 0x1b, 0x27, 0x9a, 0x92, 0xe6,
	0x9f, 0xe7, 0xef, 0x1a, 0xad, 0xb6, 0x92, 0x39, 0xfe, 0x57, 0x0e, 0x94, 0x51, 0x02, 0x12, 0x87,
	0xf4, 0xa8, 0x8f, 0x6a, 0xb0, 0x3a, 0xf6, 0x97, 0x04, 0x45, 0xf4, 0x37, 0xeb, 0x9f, 0x4a, 0xf9,
	0xd9, 0x6c, 0xa5, 0x7c, 0x0b, 0x2c, 0xa0, 0x06, 0x14, 0xc7, 0xe9, 0x1a, 0x3d, 0x9b, 0xf9, 0x9f,
	0x22, 0xf2, 0xf7, 0xd5, 0x1c, 0x6d, 0xec, 0xb0, 0x06, 0xab, 0x63, 0xa9, 0x1f, 0x2f, 0x6f, 0xd6,
	0xff, 0x87, 0xf2, 0xb3, 0xd9, 0xca, 0xd8, 0xdb, 0x2f, 0xb0, 0x3e, 0xf5, 0x5b, 0x00, 0x3d, 0x97,
	0x46, 0xf3, 0x7e, 0x2e, 0x94, 0x77, 0xe7, 0x03, 0x62, 0xcf, 0x27, 0x50, 0x88, 0x9f, 0xd7, 0x68,
	0x67, 0xfa, 0xc1, 0x1d, 0x7a, 0x2a, 0xcd, 0x7b, 0x89, 0xab, 0x0b, 0xdf, 0xa6, 0x50, 0x15, 0x60,
	0xf4, 0xec, 0x45, 0x11, 0x76, 0xea, 0x19, 0x5d, 0x7e, 0x32, 0x43, 0x13, 0x2f, 0xa4, 0x0a, 0x30,
	0x7a, 0xe4, 0xc6, 0x4e, 0xa6, 0x1e, 0xce, 0xb1, 0x93, 0x19, 0x2f, 0xe2, 0x05, 0x7e, 0xaf, 0x25,
	0x1e, 0xac, 0x28, 0xc2, 0x4e, 0xbf, 0x93, 0xcb, 0xe5, 0x59, 0xaa, 0xd8, 0x8f, 0x0e, 0x2b, 0xc9,
	0xa7, 0x2b, 0x8a, 0xd0, 0x33, 0x9e, 0xbd, 0xe5, 0xa7, 0x33, 0x75, 0xb1, 0xab, 0x0e, 0x28, 0x93,
	0x6f, 0x50, 0xf4, 0xf5, 0xf8, 0xe4, 0x93, 0x8f, 0xde, 0xf2, 0xf3, 0xb9, 0xfa, 0xc8, 0xed, 0xc9,
	0x1f, 0x3e, 0xee, 0xf7, 0x2c, 0x76, 0x3b, 0xb8, 0x3e, 0xec, 0xba, 0xfd, 0xa3, 0x9e, 0xc5, 0x3c,
	0xd7, 0x3c, 0xb0, 0x5c, 0xf9, 0x75, 0xf4, 0x10, 0x1c, 0xf4, 0xc3, 0x42, 0x39, 0x22, 0x9e, 0x75,
	0x9d, 0x13, 0x3d, 0xd5, 0xab, 0x5f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xaf, 0xab, 0x36, 0xf8, 0xce,
	0x14, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// WorkspaceManagerClient is the client API for WorkspaceManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WorkspaceManagerClient interface {
	// getWorkspaces produces a list of running workspaces and their status
	GetWorkspaces(ctx context.Context, in *GetWorkspacesRequest, opts ...grpc.CallOption) (*GetWorkspacesResponse, error)
	// startWorkspace creates a new running workspace within the manager's cluster
	StartWorkspace(ctx context.Context, in *StartWorkspaceRequest, opts ...grpc.CallOption) (*StartWorkspaceResponse, error)
	// stopWorkspace stops a running workspace
	StopWorkspace(ctx context.Context, in *StopWorkspaceRequest, opts ...grpc.CallOption) (*StopWorkspaceResponse, error)
	// describeWorkspace investigates a workspace and returns its status, and configuration
	DescribeWorkspace(ctx context.Context, in *DescribeWorkspaceRequest, opts ...grpc.CallOption) (*DescribeWorkspaceResponse, error)
	// subscribe streams all status updates to a client
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (WorkspaceManager_SubscribeClient, error)
	// markActive records a workspace as being active which prevents it from timing out
	MarkActive(ctx context.Context, in *MarkActiveRequest, opts ...grpc.CallOption) (*MarkActiveResponse, error)
	// setTimeout changes the default timeout for a running workspace
	SetTimeout(ctx context.Context, in *SetTimeoutRequest, opts ...grpc.CallOption) (*SetTimeoutResponse, error)
	// controlPort publicly exposes or un-exposes a network port for a workspace
	ControlPort(ctx context.Context, in *ControlPortRequest, opts ...grpc.CallOption) (*ControlPortResponse, error)
	// takeSnapshot creates a copy of the workspace content which can initialize a new workspace.
	TakeSnapshot(ctx context.Context, in *TakeSnapshotRequest, opts ...grpc.CallOption) (*TakeSnapshotResponse, error)
	// controlAdmission makes a workspace accessible for everyone or for the owner only
	ControlAdmission(ctx context.Context, in *ControlAdmissionRequest, opts ...grpc.CallOption) (*ControlAdmissionResponse, error)
}

type workspaceManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkspaceManagerClient(cc grpc.ClientConnInterface) WorkspaceManagerClient {
	return &workspaceManagerClient{cc}
}

func (c *workspaceManagerClient) GetWorkspaces(ctx context.Context, in *GetWorkspacesRequest, opts ...grpc.CallOption) (*GetWorkspacesResponse, error) {
	out := new(GetWorkspacesResponse)
	err := c.cc.Invoke(ctx, "/wsman.WorkspaceManager/GetWorkspaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workspaceManagerClient) StartWorkspace(ctx context.Context, in *StartWorkspaceRequest, opts ...grpc.CallOption) (*StartWorkspaceResponse, error) {
	out := new(StartWorkspaceResponse)
	err := c.cc.Invoke(ctx, "/wsman.WorkspaceManager/StartWorkspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workspaceManagerClient) StopWorkspace(ctx context.Context, in *StopWorkspaceRequest, opts ...grpc.CallOption) (*StopWorkspaceResponse, error) {
	out := new(StopWorkspaceResponse)
	err := c.cc.Invoke(ctx, "/wsman.WorkspaceManager/StopWorkspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workspaceManagerClient) DescribeWorkspace(ctx context.Context, in *DescribeWorkspaceRequest, opts ...grpc.CallOption) (*DescribeWorkspaceResponse, error) {
	out := new(DescribeWorkspaceResponse)
	err := c.cc.Invoke(ctx, "/wsman.WorkspaceManager/DescribeWorkspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workspaceManagerClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (WorkspaceManager_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_WorkspaceManager_serviceDesc.Streams[0], "/wsman.WorkspaceManager/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &workspaceManagerSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type WorkspaceManager_SubscribeClient interface {
	Recv() (*SubscribeResponse, error)
	grpc.ClientStream
}

type workspaceManagerSubscribeClient struct {
	grpc.ClientStream
}

func (x *workspaceManagerSubscribeClient) Recv() (*SubscribeResponse, error) {
	m := new(SubscribeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *workspaceManagerClient) MarkActive(ctx context.Context, in *MarkActiveRequest, opts ...grpc.CallOption) (*MarkActiveResponse, error) {
	out := new(MarkActiveResponse)
	err := c.cc.Invoke(ctx, "/wsman.WorkspaceManager/MarkActive", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workspaceManagerClient) SetTimeout(ctx context.Context, in *SetTimeoutRequest, opts ...grpc.CallOption) (*SetTimeoutResponse, error) {
	out := new(SetTimeoutResponse)
	err := c.cc.Invoke(ctx, "/wsman.WorkspaceManager/SetTimeout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workspaceManagerClient) ControlPort(ctx context.Context, in *ControlPortRequest, opts ...grpc.CallOption) (*ControlPortResponse, error) {
	out := new(ControlPortResponse)
	err := c.cc.Invoke(ctx, "/wsman.WorkspaceManager/ControlPort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workspaceManagerClient) TakeSnapshot(ctx context.Context, in *TakeSnapshotRequest, opts ...grpc.CallOption) (*TakeSnapshotResponse, error) {
	out := new(TakeSnapshotResponse)
	err := c.cc.Invoke(ctx, "/wsman.WorkspaceManager/TakeSnapshot", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workspaceManagerClient) ControlAdmission(ctx context.Context, in *ControlAdmissionRequest, opts ...grpc.CallOption) (*ControlAdmissionResponse, error) {
	out := new(ControlAdmissionResponse)
	err := c.cc.Invoke(ctx, "/wsman.WorkspaceManager/ControlAdmission", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkspaceManagerServer is the server API for WorkspaceManager service.
type WorkspaceManagerServer interface {
	// getWorkspaces produces a list of running workspaces and their status
	GetWorkspaces(context.Context, *GetWorkspacesRequest) (*GetWorkspacesResponse, error)
	// startWorkspace creates a new running workspace within the manager's cluster
	StartWorkspace(context.Context, *StartWorkspaceRequest) (*StartWorkspaceResponse, error)
	// stopWorkspace stops a running workspace
	StopWorkspace(context.Context, *StopWorkspaceRequest) (*StopWorkspaceResponse, error)
	// describeWorkspace investigates a workspace and returns its status, and configuration
	DescribeWorkspace(context.Context, *DescribeWorkspaceRequest) (*DescribeWorkspaceResponse, error)
	// subscribe streams all status updates to a client
	Subscribe(*SubscribeRequest, WorkspaceManager_SubscribeServer) error
	// markActive records a workspace as being active which prevents it from timing out
	MarkActive(context.Context, *MarkActiveRequest) (*MarkActiveResponse, error)
	// setTimeout changes the default timeout for a running workspace
	SetTimeout(context.Context, *SetTimeoutRequest) (*SetTimeoutResponse, error)
	// controlPort publicly exposes or un-exposes a network port for a workspace
	ControlPort(context.Context, *ControlPortRequest) (*ControlPortResponse, error)
	// takeSnapshot creates a copy of the workspace content which can initialize a new workspace.
	TakeSnapshot(context.Context, *TakeSnapshotRequest) (*TakeSnapshotResponse, error)
	// controlAdmission makes a workspace accessible for everyone or for the owner only
	ControlAdmission(context.Context, *ControlAdmissionRequest) (*ControlAdmissionResponse, error)
}

// UnimplementedWorkspaceManagerServer can be embedded to have forward compatible implementations.
type UnimplementedWorkspaceManagerServer struct {
}

func (*UnimplementedWorkspaceManagerServer) GetWorkspaces(ctx context.Context, req *GetWorkspacesRequest) (*GetWorkspacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkspaces not implemented")
}
func (*UnimplementedWorkspaceManagerServer) StartWorkspace(ctx context.Context, req *StartWorkspaceRequest) (*StartWorkspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWorkspace not implemented")
}
func (*UnimplementedWorkspaceManagerServer) StopWorkspace(ctx context.Context, req *StopWorkspaceRequest) (*StopWorkspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopWorkspace not implemented")
}
func (*UnimplementedWorkspaceManagerServer) DescribeWorkspace(ctx context.Context, req *DescribeWorkspaceRequest) (*DescribeWorkspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeWorkspace not implemented")
}
func (*UnimplementedWorkspaceManagerServer) Subscribe(req *SubscribeRequest, srv WorkspaceManager_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (*UnimplementedWorkspaceManagerServer) MarkActive(ctx context.Context, req *MarkActiveRequest) (*MarkActiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkActive not implemented")
}
func (*UnimplementedWorkspaceManagerServer) SetTimeout(ctx context.Context, req *SetTimeoutRequest) (*SetTimeoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTimeout not implemented")
}
func (*UnimplementedWorkspaceManagerServer) ControlPort(ctx context.Context, req *ControlPortRequest) (*ControlPortResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ControlPort not implemented")
}
func (*UnimplementedWorkspaceManagerServer) TakeSnapshot(ctx context.Context, req *TakeSnapshotRequest) (*TakeSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TakeSnapshot not implemented")
}
func (*UnimplementedWorkspaceManagerServer) ControlAdmission(ctx context.Context, req *ControlAdmissionRequest) (*ControlAdmissionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ControlAdmission not implemented")
}

func RegisterWorkspaceManagerServer(s *grpc.Server, srv WorkspaceManagerServer) {
	s.RegisterService(&_WorkspaceManager_serviceDesc, srv)
}

func _WorkspaceManager_GetWorkspaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkspacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkspaceManagerServer).GetWorkspaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wsman.WorkspaceManager/GetWorkspaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkspaceManagerServer).GetWorkspaces(ctx, req.(*GetWorkspacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkspaceManager_StartWorkspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWorkspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkspaceManagerServer).StartWorkspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wsman.WorkspaceManager/StartWorkspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkspaceManagerServer).StartWorkspace(ctx, req.(*StartWorkspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkspaceManager_StopWorkspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopWorkspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkspaceManagerServer).StopWorkspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wsman.WorkspaceManager/StopWorkspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkspaceManagerServer).StopWorkspace(ctx, req.(*StopWorkspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkspaceManager_DescribeWorkspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeWorkspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkspaceManagerServer).DescribeWorkspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wsman.WorkspaceManager/DescribeWorkspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkspaceManagerServer).DescribeWorkspace(ctx, req.(*DescribeWorkspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkspaceManager_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkspaceManagerServer).Subscribe(m, &workspaceManagerSubscribeServer{stream})
}

type WorkspaceManager_SubscribeServer interface {
	Send(*SubscribeResponse) error
	grpc.ServerStream
}

type workspaceManagerSubscribeServer struct {
	grpc.ServerStream
}

func (x *workspaceManagerSubscribeServer) Send(m *SubscribeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _WorkspaceManager_MarkActive_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkActiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkspaceManagerServer).MarkActive(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wsman.WorkspaceManager/MarkActive",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkspaceManagerServer).MarkActive(ctx, req.(*MarkActiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkspaceManager_SetTimeout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTimeoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkspaceManagerServer).SetTimeout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wsman.WorkspaceManager/SetTimeout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkspaceManagerServer).SetTimeout(ctx, req.(*SetTimeoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkspaceManager_ControlPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ControlPortRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkspaceManagerServer).ControlPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wsman.WorkspaceManager/ControlPort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkspaceManagerServer).ControlPort(ctx, req.(*ControlPortRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkspaceManager_TakeSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TakeSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkspaceManagerServer).TakeSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wsman.WorkspaceManager/TakeSnapshot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkspaceManagerServer).TakeSnapshot(ctx, req.(*TakeSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkspaceManager_ControlAdmission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ControlAdmissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkspaceManagerServer).ControlAdmission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/wsman.WorkspaceManager/ControlAdmission",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkspaceManagerServer).ControlAdmission(ctx, req.(*ControlAdmissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _WorkspaceManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "wsman.WorkspaceManager",
	HandlerType: (*WorkspaceManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetWorkspaces",
			Handler:    _WorkspaceManager_GetWorkspaces_Handler,
		},
		{
			MethodName: "StartWorkspace",
			Handler:    _WorkspaceManager_StartWorkspace_Handler,
		},
		{
			MethodName: "StopWorkspace",
			Handler:    _WorkspaceManager_StopWorkspace_Handler,
		},
		{
			MethodName: "DescribeWorkspace",
			Handler:    _WorkspaceManager_DescribeWorkspace_Handler,
		},
		{
			MethodName: "MarkActive",
			Handler:    _WorkspaceManager_MarkActive_Handler,
		},
		{
			MethodName: "SetTimeout",
			Handler:    _WorkspaceManager_SetTimeout_Handler,
		},
		{
			MethodName: "ControlPort",
			Handler:    _WorkspaceManager_ControlPort_Handler,
		},
		{
			MethodName: "TakeSnapshot",
			Handler:    _WorkspaceManager_TakeSnapshot_Handler,
		},
		{
			MethodName: "ControlAdmission",
			Handler:    _WorkspaceManager_ControlAdmission_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _WorkspaceManager_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "core.proto",
}
